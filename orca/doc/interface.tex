%
% (c) copyright 1995 by the Vrije Universiteit, Amsterdam, The Netherlands.
% For full copyright and restrictions on use see the file COPYRIGHT in the
% top level of the Orca distribution.
%

\documentclass[10pt]{article}

\setlength{\textheight}{9in}
\setlength{\textwidth}{6.75in}
\setlength{\oddsidemargin}{-0.19in}
\setlength{\evensidemargin}{-0.19in}
\setlength{\topmargin}{-0.25in}

\begin{document}
\title{Orca Runtime-system Implementors Guide}
\author{
Ceriel J.H. Jacobs \\
Dept. of Mathematics and Computer Science \\
Vrije Universiteit \\
Amsterdam \\
the Netherlands}

\maketitle

\section{Introduction}\label{sec:intro}
This paper describes the interface between the Orca compiler and the
runtime-system (RTS).
The primitives specified in this paper are to be provided by any Orca
RTS.

The target language of the Orca compiler is (ANSI) C, 
and the Orca RTS depends heavily on the runtime support given by C.
Therefore, no special support is needed for (recursive) procedure calls
or scalar variables.
However, C only has a rudimentary support for complex data structures, 
whereas Orca treats them as first class citizens.
Many of the type-specific Orca features, such as assignment, marshalling,
and comparison, are generated by the compiler.
For some Orca features, however, runtime support is required.
This support is provided by a RTS.
The interface is summarized in
the include file {\em interface.h}.

For every Orca type, the Orca compiler generates
a type descriptor.
In addition, the Orca compiler generates type-specific functions for
assignment, comparison, cleaning-up, and marshalling.
The type-specific functions are the subject of section \ref{sec:tpspec}.
Type descriptors are described in section \ref{sec:tpdesc}.
Section \ref{sec:mapping} discusses the mapping of Orca data structures onto C
data structures.
The interface to the RTS as far as data management is concerned is
described in section \ref{sec:dataman}.
Operations are discussed in section \ref{sec:ops}, and section \ref{sec:procs} deals with processes.
\section{Type-specific functions}\label{sec:tpspec}
The following Orca-type specific functions are generated:
\begin{description}
\item[assignment]
For every Orca type a routine exists with the following interface:
\begin{quote}
\begin{verbatim}
void <assignfunc>(void *dst, void *src);
\end{verbatim}
\end{quote}
This function first removes the value of \verb+dst+ and then assigns
a copy of \verb+src+ to it.
\item[comparison]
For every Orca type for which comparison is allowed a routine exists
with the following interface:
\begin{quote}
\begin{verbatim}
int <comparefunc>(void *a, void *b);
\end{verbatim}
\end{quote}
This function returns 1 if the values are equal, 0 if they are not.
\item[freeing]
For every Orca type which contains dynamically allocated parts, a routine
exists with the following interface:
\begin{quote}
\begin{verbatim}
void <freefunc>(void *a);
\end{verbatim}
\end{quote}
This function cleans up (frees) the dynamically allocated parts.
\item[marshalling and unmarshalling]
There are two different marshalling schemes, an "old" one and a "new" one.
In the old one, for every Orca type \verb+tp+ the following routines exist:
\begin{quote}
\begin{verbatim}
int <szfunc>(tp *arg);
char *<mafunc>(char *buf, tp *arg);
char *<umfunc>(char *buf, tp *arg);
\end{verbatim}
\end{quote}
The \verb+szfunc+
function computes the size of the buffer required to store
the marshalled argument.
The \verb+mafunc+ function marshalls the argument into \verb+buf+ and
returns a pointer to the next free entry in \verb+buf+.
The \verb+umfunc+
function unmarshalls the buffer into \verb+arg+
and
returns a pointer to the next entry in \verb+buf+.
The new scheme, which is specific for PANDA version 4, and which is
enabled by compiling the generated C-code with the \verb+PANDA4+ define,
is quite different.
Instead of marshalling the data into a buffer, in the new scheme an IO
vector is built, which contains a list of pointer-size pairs.
The following functions exist:
\begin{quote}
\begin{verbatim}
int <szfunc>(tp *arg);
pan_iovec_p <mafunc>(pan_iovec_p p, tp *arg);
void <umfunc>(void *buf, tp *arg);
\end{verbatim}
\end{quote}
The \verb+szfunc+
function computes the length of the IO vector required for
the marshalled argument.
The \verb+mafunc+
function stores pointer-size pairs for the argument into
\verb+p+
and returns a pointer to the next free entry in \verb+p+.
The \verb+umfunc+
function unmarshalls (part of) the message \verb+buf+
into \verb+arg+.
\end{description}

Most of these functions will only be called by compiler-generated code,
but sometimes the RTS may need to call them.
In these cases, the functions are made available to the RTS through
the type-descriptors, as function pointers.

For user-defined types, the compiler generates all these functions, but
for the Orca built-in types, the RTS must provide them. This concerns the
following functions:
\begin{quote}
\begin{verbatim}
/* marshalling for strings */
#ifdef PANDA4
int sz_string(t_string *s);
pan_iovec_p ma_string(pan_iovec_p buf, t_string *s);
void um_string(void *buf, t_string *s);
#else
int sz_string(t_string *s);
char *ma_string(char *buf, t_string *s);
char *um_string(char *buf, t_string *s);
#endif

/* cleanup for strings */
void free_string(void *s);

/* assignment and comparison */
void ass_string(void *dst, void *src);
int cmp_string(void *a, void *b);
void ass_enum(void *dst, void *src);
int cmp_enum(void *a, void *b);
void ass_longenum(void *dst, void *src);
int cmp_longenum(void *a, void *b);
void ass_integer(void *dst, void *src);
int cmp_integer(void *a, void *b);
void ass_longint(void *dst, void *src);
int cmp_longint(void *a, void *b);
void ass_real(void *dst, void *src);
int cmp_real(void *a, void *b);
void ass_longreal(void *dst, void *src);
int cmp_longreal(void *a, void *b);
void ass_nodename(void *dst, void *src);
int cmp_nodename(void *a, void *b);
\end{verbatim}
\end{quote}

\section{Type descriptors}\label{sec:tpdesc}

For every type, either user-defined or built-in,
a type descriptor exists at runtime.
These descriptors are constant,
and are created using the structure-initializing mechanism of C.
The type descriptor structure would be best represented as a structure
containing a common part for all descriptors, and a union for the
part that differs, depending on the type described.
Unfortunately, union initialization as would be needed for 
such an implementation does not exist in
ANSI C, so instead there is one descriptor structure that is able to
describe all data types,
and we use macros to access some of the fields.
The fields that all type descriptors have in common are:
\begin{description}
\item[{\tt td\_type}]
indicates the basic type of the descriptor
(and the data it describes).
\item[{\tt td\_size}]
indicates the size of variables of this type (in bytes), as the compiler
allocates them (this does not always indicate the
real size, because some parts may be allocated dynamically).
\item[{\tt td\_flags}]
Currently used for the following flags:
\begin{description}
\item[{\tt DYNAMIC}]
indicates that the type has parts that must be allocated dynamically.
\item[{\tt NO\_EQ}]
indicates that the type may not be compared for equality.
\item[{\tt HAS\_OBJECTS}]
indicates that the type has an object type as sub-type.
\item[{\tt INIT\_CODE}]
indicates that the type needs initialization.
\end{description}
Other flags may be added later.
\end{description}
The other fields depend on the value of the \verb+td_type+
field and are described
below.

\subsection{Basic types}
The following table gives the mapping of most of the Orca basic types
to the \verb+td_type+
field of their type descriptor structure.

\begin{quote}
\begin{tabular}{|l|l|}\hline
{\bf Orca type } & \verb+td_type+ \\ \hline
{\em integer} & \verb+INTEGER+ \\
{\em real} & \verb+REAL+ \\
{\em char} & \verb+CHAR+ \\ \hline
\end{tabular}
\end{quote}

The type descriptors of the Orca boolean and string types are as if these
types are declared as follows:
\begin{quote}
\begin{verbatim}
TYPE boolean = (FALSE, TRUE);
TYPE string = ARRAY [integer] OF char;
\end{verbatim}
\end{quote}

\subsection{Enumeration types}
For descriptors of enumeration types, the \verb+td_type+
field has either the value
\verb+ENUM+
or \verb+LONGENUM+, depending on whether the number of
enumeration literals of this type fits in one byte or not.
The type descriptor contains the following extra field, accessible through
a macro with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_nenums(tp)}]
an integer representing the number of enumeration literals in this type.
\end{description}

\subsection{Record types}
For descriptors of records, the \verb+td_type+
field has the value \verb+RECORD+.
The type descriptor contains the following extra fields, accessible through
macros with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_nfields(tp)}]
an integer representing the number of fields in this record.
\item[{\tt td\_fields(tp)}]
a pointer indicating an array, with one entry for each field,
each entry having the following structure:
\begin{quote}
\begin{verbatim}
typedef struct fld_descr {
     size_t    fld_offset;
     tp_dscr  *fld_descr;
} fld_dscr;
\end{verbatim}
\end{quote}
The offset of the field within the record is given by \verb+fld_offset+,
and its type descriptor is indicated by \verb+fld_descr+.
\end{description}

\subsection{Union types}
For descriptors of unions, the \verb+td_type+
field has the value \verb+UNION+.
The type descriptor contains the following extra fields, accessible through
macros with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_tagdscr(tp)}]
a pointer indicating the type descriptor of the union tag.
\item[{\tt td\_nvariants(tp)}]
an integer representing the number of union variants.
\item[{\tt td\_variants(tp)}]
a pointer indicating an array, with one entry for each
variant, each entry having the following structure:
\begin{quote}
\begin{verbatim}
typedef struct variant_descr {
     t_integer var_tagval;
     size_t    var_offset;
     tp_dscr  *var_descr;
} var_dscr;
\end{verbatim}
\end{quote}
The tag value of this variant is given by \verb+var_tagval+,
the offset of this variant within the union is given by \verb+var_offset+,
and the type descriptor of this variant is given by \verb+var_descr+.
\end{description}

\subsection{Array types}
For descriptors of arrays, the \verb+td_type+
field has the value \verb+ARRAY+.
The type descriptor contains the following extra fields, accessible through
macros with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_elemdscr(tp)}]
a pointer indicating the type descriptor of the array elements.
\item[{\tt td\_ndim(tp)}]
the number of dimensions of the array.
\item[{\tt td\_indexdscr(tp)}]
a pointer indicating an array of index type descriptors, one for each
dimension.
\end{description}

\subsection{Set and bag types}
For descriptors of sets, the \verb+td_type+
field has the value \verb+SET+.
For descriptors of bags, the \verb+td_type+
field has the value \verb+BAG+.
For both,
the type descriptor contains the following extra fields, accessible through
macros with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_elemdscr(tp)}]
a pointer indicating the type descriptor of the set or bag elements.
\item[{\tt td\_setdscr(tp)}]
a pointer to a structure of the following type:
\begin{quote}
\begin{verbatim}
typedef struct set_descr {
     void      (*set_free)(void *);
     void      (*set_assign)(void *, void *);
     int       (*set_elcompare)(void *, void *);
     void      (*set_elfree)(void *);
     void      (*set_elassign)(void *, void *);
} set_dscr;
\end{verbatim}
\end{quote}
These function pointers may be used to implement the set/bag operations.
There are entries to free the set, free a set element, compare two set elements,
assign set elements, and assign sets.
\end{description}

\subsection{Graph and nodename types}
For descriptors of graphs, the \verb+td_type+
field has the value \verb+GRAPH+.
The type descriptor contains the following extra fields, accessible through
macros with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_rootdscr(tp)}]
a pointer indicating the type descriptor of the root of the
graph type, as a record type.
\item[{\tt td\_nodedscr(tp)}]
a pointer indicating the type descriptor of a node of the
graph type, again as a record.
\item[{\tt td\_rootoff(tp)}]
an integer representing the offset of the root record within the
graph structure as it is allocated by the compiler
(a graph is represented as a C struct with,
among others, a structure for the root record.
See section \ref{sec:graphtype}).
\end{description}
For descriptors of nodenames, the \verb+td_type+
field has the value \verb+NODENAME+.
The type descriptor contains the following extra field, accessible through
a macro with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_graphdscr(tp)}]
a pointer indicating the type descriptor of the graph type of
the nodename type.
\end{description}

\subsection{Function types}
For descriptors of functions, the \verb+td_type+
field has the value \verb+FUNCTION+.
The type descriptor contains the following extra fields, accessible through
macros with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_resultdscr(tp)}]
a pointer indicating the type descriptor of the result type
of this function type.
\item[{\tt td\_nparams(tp)}]
an integer representing the number of parameters.
\item[{\tt td\_params(tp)}]
a pointer indicating an array of parameter descriptors,
with one element for each parameter.
The parameter descriptor has the following structure:
\begin{quote}
\begin{verbatim}
typedef struct param_descr {
     int       par_mode;        /* IN, OUT or SHARED */
#define IN     0
#define OUT    1
#define SHARED 2
     tp_dscr  *par_descr;       /* type descriptor of parameter */
     void    (*par_copy)(void *, void *);
                                /* assignment routine for parameter */
     void    (*par_free)(void *);
                                /* cleanup routine for parameter */
} par_dscr;
\end{verbatim}
\end{quote}
\end{description}

\subsection{Object types}
For descriptors of objects, the \verb+td_type+
field has the value \verb+OBJECT+.
The type descriptor contains the following extra fields, accessible through
macros with argument \verb+tp+, which is a pointer to the descriptor:
\begin{description}
\item[{\tt td\_objrec(tp)}]
a pointer indicating the type descriptor of the record containing the
object fields.
\item[{\tt td\_objinfo(tp)}]
a pointer to an object descriptor. An object descriptor has the following type:
\begin{quote}
\begin{verbatim}
typedef struct obj_info {
     int         (*obj_size_obj)(t_object *obj);
#ifdef PANDA4
     pan_iovec_p (*obj_marshall_obj)(pan_iovec_p buf, t_object *obj);
     void        (*obj_unmarshall_obj)(void *buf, t_object *obj);
#else
     char       *(*obj_marshall_obj)(char *buf, t_object *obj);
     char       *(*obj_unmarshall_obj)(char *buf, t_object *obj);
#endif
     void        (*obj_rec_free)(void *);
     op_dscr      *obj_operations;
} obj_info;
\end{verbatim}
\end{quote}
\verb+Obj_size_obj+, \verb+obj_marshall_obj+,
and \verb+obj_unmarshall_obj+
are pointers to marshalling functions, as described above.
\verb+Obj_operations+
is
a pointer indicating an array of operation descriptors, with one
element for each user-defined operation.
The operation descriptors will be discussed below.
\item[{\tt td\_registration(tp)}]
an integer representing the registration number of this object descriptor.
All addresses that may have to be marshalled are registered by the
RTS, so that an integer is marshalled instead of a pointer.
\end{description}
Operation descriptors are used for marshalling parameters during a
remotely executed operation.
Operations can have OUT parameters and result values.
The compiler divides the guards of an operation into two groups:
those that only read the object and those that may read
and modify the object's data.
These groups are translated into separate procedures.
An operation descriptor has the following structure:
\begin{quote}
\begin{verbatim}
typedef struct op_descr {
     void        (*op_read_alts)(t_object *, void **);
     void        (*op_write_alts)(t_object *, void **);
     tp_dscr      *op_func;     /* a function descriptor for the operation */
     int           op_index;    /* all operations on an object are
                                   numbered for identification purposes.
                                   This is the number.
                                */
     int           op_flags;
#define OP_BLOCKING     01
#define OP_PURE_WRITE   02
     char         *op_trc_name;	/* name of this operation (for tracing) */
     int         (*op_size_op_call)(void **);
#ifdef PANDA4
     pan_iovec_p (*op_marshall_op_call)(pan_iovec_p, void **);
     void        (*op_unmarshall_op_call)(void *, void ***);
                                /* creates the argument vector, hence the *** */
#else
     char       *(*op_marshall_op_call)(char *, void **);
     char       *(*op_unmarshall_op_call)(char *, void ***);
#endif
     int         (*op_size_op_return)(void **);
#ifdef PANDA4
     pan_iovec_p (*op_marshall_op_return)(pan_iovec_p, void **);
     void        (*op_unmarshall_op_return)(void *, void **);
#else
     char       *(*op_marshall_op_return)(char *, void **);
     char       *(*op_unmarshall_op_return)(char *, void **);
#endif
     void        (*op_free_op_return)(void **);
} op_dscr;
\end{verbatim}
\end{quote}
The structure contains the addresses of two routines, one implementing the
read-alternatives, and one implementing the write-alternatives.
These routines have two parameters: one indicating the object, and the second
indicating a list of addresses of the parameters and the result type.

In addition, there are entry points for marshalling: three for 
computing the size, marshalling, and unmarshalling of the operation call,
three for computing the size, marshalling, and unmarshalling of the operation
return, and one for the cleaning up of operation parameters.

\section{Data representation}\label{sec:mapping}
For every variable, space is allocated by the compiler.
However, some types have a size that cannot be determined at compile time.
For these types, storage is allocated by the RTS, using the
type descriptors described above.
This paragraph discusses the mapping of the Orca types to C types.

\subsection{Basic types}

The following table gives the mapping of most of the Orca basic types
to the corresponding C type identifier, and how the latter is
defined.

\begin{quote}
\begin{tabular}{|l|l|l|}\hline
{\bf Orca type} & {\bf C type} & {\bf defined as} \\ \hline
{\em shortint} & \verb+t_shortint+ & \verb+short+ \\
{\em integer} & \verb+t_integer+ & \verb+int+ \\
{\em longint} & \verb+t_longint+ & \verb+long+ \\
{\em shortreal} & \verb+t_shortreal+ & \verb+float+ \\
{\em real} & \verb+t_real+ & \verb+double+ \\
{\em longreal} & \verb+t_longreal+ & \verb+double+ \\
{\em char} & \verb+t_char+ & \verb+unsigned char+ \\ \hline
\end{tabular}
\end{quote}

The Orca boolean and string types are handled as if they are
declared as follows:
\begin{quote}
\begin{verbatim}
TYPE boolean = (FALSE, TRUE);
TYPE string = ARRAY [integer] OF char;
\end{verbatim}
\end{quote}

\subsection{Enumeration types}
If the number of enumeration literals of the type fits in one byte,
the corresponding C type is \verb+unsigned char+,
otherwise it is \verb+unsigned int+.

\subsection{Record types}
The C representation of a record consists of a C struct with one
field for each field in the Orca record.

\subsection{Union types}
The C representation of a union consists of a struct containing:
\begin{itemize}
\item
the tag value of the union, represented as a \verb+t_integer+.
\item
a flag indicating whether the union is initialized (selecting a variant
of an uninitialized union must result in a runtime error).
\item
a C union with one variant for each of the variants of the Orca union.
\end{itemize}

\subsection{Array types}
The C representation of an array consists of a structure containing:
\begin{description}
\item[{\tt a\_sz}]
an integer representing the total number of elements in the array.
\item[{\tt a\_offset}]
an integer used for indexing the array, as described below.
\item[{\tt a\_data}]
a pointer indicating a C array containing the array elements.
When this pointer is cast to a pointer to the element type, and then
indexed with \verb+a_offset+, like this:
\begin{quote}
\begin{verbatim}
((elemtype *) a_data)[a_offset]
\end{verbatim}
\end{quote}
this gives the first element of the array.
\item[{\tt a\_dims}]
an array of structures, one for each dimension.
These structures contain two fields: \verb+a_lwb+ is an integer
representing the lower bound of this dimension, and \verb+a_nel+
is an integer representing the number of elements in this dimension.
\end{description}

\subsection{Set and bag types}
The C representation of bags is similar to the C representation of sets,
so we only discuss the set representation here.
The C representation of a set is a structure containing:
\begin{description}
\item[{\tt s\_nelem}]
an integer representing the number of elements.
\item[{\tt s\_elem}]
a pointer to a linked list of set element structures.
The set element structure has two fields: one is a header structure and
one is an array of set elements.
Currently, the size of this array is 16. The header structure consists of
three fields: one indicating the next set element structure, one indicating
the number of elements in the set contributed by this element structure,
and a bit mask indicating which entries of the array of set elements are
currently a member of the set.
\end{description}

\subsection{Graph and nodename types}\label{sec:graphtype}
The C representation of a graph is a structure containing
the following fields:
\begin{description}
\item[{\tt g\_size}]
an integer representing the size of the master table.
\item[{\tt g\_mt}]
a pointer indicating the master table.
\item[{\tt g\_freelist}]
a pointer to the start of the list of free entries
in the master table.
\item[{\tt g\_freenodes}]
a list of free nodes of the graph.
\item[{\tt g\_ndlist}]
a list of blocks of nodes, as they are allocated.
This list is needed to be able to remove the graph.
\item[{\tt g\_root}]
a C structure representing the root record of the graph.
\end{description}
The master table is an array of structures containing two fields:
\begin{description}
\item[{\tt g\_age}]
an integer representing the age field of this entry.
\item[{\tt g\_node}]
a pointer indicating a structure containing a node of the graph.
\end{description}
The \verb+g_age+
field is used for checking validity of access to the
graph, and also to indicate whether the entry is free.
An even \verb+g_age+
value indicates that the entry is free, and in this case
\verb+g_node+
is used, together with the \verb+g_freelist+
field, to maintain
a list of free master table entries.
This simplifies an efficient implementation of \verb+ADDNODE+.

The C representation of a nodename is a structure containing:
\begin{description}
\item[{\tt n\_age}]
an integer representing the age field of the nodename.
\item[{\tt n\_index}]
an integer representing the index in the master table of the node indicated.
\end{description}

\subsection{Function types}
The C representation of an Orca function variable is a \verb+t_integer+.
All functions that are assigned to a function variable must be
registered to the RTS, which assigns to it a unique integer
value (which can also be used to marshall the function value).

\subsection{Object types}
The C representation of an Orca object type variable is a structure
containing the following fields:
\begin{description}
\item[{\tt o\_fields}]
a pointer indicating a record structure containing the object fields.
\item[{\tt o\_rtsdep}]
a RTS dependent structure.
This is the place where the RTS may place its RTS dependent info
about the object.
\end{description}

\section{Data management}\label{sec:dataman}
In a previous paragraph we discussed the representation of Orca data.
Although some of the more complex Orca data structures have a direct
equivalent in C, Orca allows operations on them that are not
directly supported by C,
and thus need to be provided by the compiler or the RTS.
This paragraph discusses the routines that must be provided by the
RTS, as far as data management is concerned.
All these may also be provided as a macro.

\subsection{Basic types and enumeration types}
No special runtime support is needed for basic or enumeration types
(except for strings, but a string is an array).

\subsection{Record types}
The special support routines required are generated by the compiler.

\subsection{Union types}
For field selection, there exists
a direct equivalent in C, but in Orca field selection of a union is
safe.
A runtime check must be performed on the tag value of the union.
For this purpose the RTS should provide a routine:
\begin{quote}
\begin{verbatim}
void u_check(void *u, t_integer tv, char *fn, int ln);
\end{verbatim}
\end{quote}
where \verb+u+ is a pointer to the C struct implementing the union,
and \verb+tv+ is the required value of the union tag.
This routine performs the check and a runtime error occurs when either
the union is not initialized or the union tag does not have the
required value.
The filename and linenumber are provided to produce a sensible error message
in case of a runtime error.

There also is an initialization routine:
\begin{quote}
\begin{verbatim}
void u_initialize(void *u, char *name);
\end{verbatim}
\end{quote}
The name may be used for tracing, but can safely be ignored.

\subsection{Array types}
The possible operators that can be applied to an array are:
\begin{itemize}
\item
allocation.
Because Orca arrays are dynamic in nature, they are allocated dynamically.
The RTS should provide a routine
\begin{quote}
\begin{verbatim}
void a_allocate(void *a, int ndim, size_t elsz, ...);
\end{verbatim}
\end{quote}
to allocate an array.
The array bounds are in the variable parameter list. For each dimension,
the lower bound and the upper bound must be given.
Space for dynamic components is not allocated yet, because the
required size is probably not known yet.
\end{itemize}
For array selection, there is no direct equivalent in C, as C array selection
is unsafe, and Orca arrays are represented differently.
The RTS should provide a routine
\begin{quote}
\begin{verbatim}
void a_check(void *a, int i, int dim, char *fn, int ln);
\end{verbatim}
\end{quote}
which checks that \verb+i+ is a valid
index for array \verb+a+, dimension \verb+dim+,
and causes a runtime error otherwise.
The filename and linenumber are provided to produce a sensible error message
in case of a runtime error.

For initializing,
for determining the number of elements in an array (\verb+SIZE+)
and determining the upper or lower bound (\verb+LB+, \verb+UB+),
the following routines are used respectively:
\begin{quote}
\begin{verbatim}
void a_initialize(void *a, char *s);
t_integer a_size(void *a);
t_integer a_lb(void *a, int dimno);
t_integer a_ub(void *a, int dimno);
\end{verbatim}
\end{quote}
The initializing routine has a second parameter for uniformity with other
initialization routines, some of which are produced by the compiler.
This second parameter may be used for tracing, but may also be ignored.

\subsection{Set and bag types}
The possible operators that can be applied to a set and for which runtime
support is needed are:
\begin{itemize}
\item
adding an element (\verb+INSERT+).
The RTS provides a routine
\begin{quote}
\begin{verbatim}
void s_addel(t_set *s, tp_dscr *d, void *el);
\end{verbatim}
\end{quote}
which adds an element to set \verb+s+.
The address of the element is passed in \verb+el+.
\item
deleting an element (\verb+DELETE+).
The RTS provides a routine
\begin{quote}
\begin{verbatim}
void s_delel(t_set *s, tp_dscr *d, void *el);
\end{verbatim}
\end{quote}
which removes an element from set \verb+s+.
The address of the element is passed in \verb+el+.
\item
testing for membership (\verb+IN+).
The RTS provides a routine
\begin{quote}
\begin{verbatim}
t_boolean s_member(t_set *s, tp_dscr *d, void *el);
\end{verbatim}
\end{quote}
which tests for membership of set \verb+s+.
The address of the element is passed in \verb+el+.
\item
removing and returning a random element (\verb+FROM+).
The RTS provides routines
\begin{quote}
\begin{verbatim}
void s_fromcheck(t_set *s, char *fn, int ln);
void s_from(t_set *s, tp_dscr *d, void *result);
\end{verbatim}
\end{quote}
The routine \verb+s_fromcheck+ checks that the set is not empty, and
produces a runtime error otherwise.
The routine \verb+s_from+
removes and stores in \verb+result+
a random element
from set \verb+s+.
\item
set arithmetic: set union, difference, intersection and
symmetric difference.
The RTS provides the following routines:
\begin{quote}
\begin{verbatim}
void s_add(t_set *a, t_set *b, tp_dscr *d);
void s_sub(t_set *a, t_set *b, tp_dscr *d);
void s_inter(t_set *a, t_set *b, tp_dscr *d);
void s_symdiff(t_set *a, t_set *b, tp_dscr *d);
\end{verbatim}
\end{quote}
In addition, the following two routines are used for initialization and
\verb+SIZE+ respectively:
\begin{quote}
\begin{verbatim}
void s_initialize(t_set *s, char *n);
t_integer s_size(t_set *s);
\end{verbatim}
\end{quote}
\end{itemize}
For bags, a similar interface exists, but these routines have \verb+b_+
in front of their name instead of \verb+s_+, and have \verb+t_bag+
operands instead of \verb+t_set+.

\subsection{Graph and nodename types}
The possible operators that can be applied to a graph and for which runtime
support is needed are:
\begin{itemize}
\item
node selection.
The RTS should provide a routine
\begin{quote}
\begin{verbatim}
void g_check(void *g, t_nodename *n, char *fn, int ln);
\end{verbatim}
\end{quote}
which checks that \verb+n+ indicates
a valid nodename for the graph indicated by \verb+g+ and causes a runtime
error otherwise.
The filename and linenumber are provided to produce a sensible error message
in case of a runtime error.
For convenience, the routine \verb+g_elem+
for unchecked graph access
should be provided. It returns a pointer to the node.
\begin{quote}
\begin{verbatim}
void *g_elem(void *g, t_nodename *n);
\end{verbatim}
\end{quote}
\item
adding a node (\verb+ADDNODE+).
The RTS should provide a routine
\begin{quote}
\begin{verbatim}
void g_addnode(t_nodename *res, void *g, size_t sz);
\end{verbatim}
\end{quote}
which adds a node (of size \verb+sz+) to the graph indicated by \verb+g+
and stores the result in \verb+res+.
\item
deleting a node (\verb+DELETENODE+).
The RTS provides a routine
\begin{quote}
\begin{verbatim}
void g_deletenode(t_nodename *n, void *g, void (*freefunc)(void *));
\end{verbatim}
\end{quote}
which deletes the node indicated by \verb+n+ from the graph indicated
by \verb+g+.
\verb+Freefunc+
is either 0 or a function which must be called to free
the node contents.
\item
For initialization, the following functions are provided:
\begin{quote}
\begin{verbatim}
void g_initialize(void *g, char *name);
void n_initialize(t_nodename *n, char *name);
\end{verbatim}
\end{quote}
\item
To test if a nodename is NIL, the following routine is used:
\begin{quote}
\begin{verbatim}
int n_isnil(t_nodename *n);
\end{verbatim}
\end{quote}
\item
Also, to assist in graph assignment and graph cleaning, the following
routines must be provided:
\begin{quote}
\begin{verbatim}
void *g_getnode(void *g, size_t sz);
void g_freeblocks(void *g);
\end{verbatim}
\end{quote}
\verb+G_getnode+ obtains a null-initialized node for graph \verb+g+.
\verb+G_freeblocks+ frees all node space obtained through \verb+g_addnode+
or \verb+g_getnode+ (for graph \verb+g+).
\end{itemize}

\subsection{Function types}
No special runtime support is needed for functions.
See also section \ref{sec:rtsproc}

\subsection{Object types}
Operations on objects will be discussed in section \ref{sec:ops}.
In this section we will only discuss the operators on objects as a whole.
Objects are allocated dynamically.
The RTS should provide the following routine:
\begin{quote}
\begin{verbatim}
void o_init_rtsdep(t_object *o, tp_dscr *d, char *n);
\end{verbatim}
\end{quote}
which initializes the RTS-dependent part of the object.

The RTS should also provide the following routine:
\begin{quote}
\begin{verbatim}
int o_free(t_object *o);
\end{verbatim}
\end{quote}
which tells the RTS that there is one less reference to the object.
The RTS may conclude that the object must be freed, in which case it
must free the RTS-dependent part itself, and return 1 (indicating to the
calling routine that it must cleanup the data part of the object).
If the object must not be freed, \verb+o_free+ should return 0.

\section{Operations}\label{sec:ops}
To implement operations efficiently, the compiler will generate code
that differentiates between the possible cases.
For instance, the compiler may know that an object is local or nested,
or that it is shared.
It may also know whether an operation only reads the object, it may
know whether the operation may block, et cetera.

\subsection{Runtime-system support for operations}
For implementing operations, the RTS should provide the following routines:
\begin{quote}
\begin{verbatim}
t_boolean o_start_read(t_object *o);
\end{verbatim}
\end{quote}
which tests if a read operation on object \verb+o+ may be done locally,
and gives the RTS the opportunity to set a read lock.
\begin{quote}
\begin{verbatim}
void o_end_read(t_object *o);
\end{verbatim}
\end{quote}
which indicates to the RTS that a read operation has been performed locally
(of course after a successful call to \verb+o_start_read+), and that the read lock
may be released.
\begin{quote}
\begin{verbatim}
t_boolean o_start_write(t_object *o);
\end{verbatim}
\end{quote}
which tests if a write operation on object \verb+o+ may be done locally,
and gives the RTS the opportunity to set a write lock.
\begin{quote}
\begin{verbatim}
void o_end_write(t_object *o, int result);
\end{verbatim}
\end{quote}
which indicates to the RTS that a write operation has been attempted locally
(of course after a successful call to \verb+o_start_write+), and that the write lock
may be released.
If \verb+result+
is set, the object has indeed been written.
\begin{quote}
\begin{verbatim}
int o_isshared(t_object *o);
\end{verbatim}
\end{quote}
which returns 1 if the object is shared, 0 if it is not.
\begin{quote}
\begin{verbatim}
void DoOperation(t_object *o, int *op_flags, tp_dscr *d, int opindex,
                 int attempted, void **args);
\end{verbatim}
\end{quote}
This routine is called when an attempt to perform the operation locally has
failed (because the RTS did not allow it or the operation has guards).
On entry, \verb+op_flags+
indicates whether the operation is nested (\verb+NESTED+),
on return it indicates whether the operation blocks (\verb+BLOCKING+).
The object type descriptor is indicated by \verb+d+, the index of this
operation in the list of operations on this object type is given by
\verb+opindex+, \verb+attempted+ indicates what has already been tried
locally but would block (\verb+0+, \verb+READS+, \verb+WRITES+,
or \verb+READS$|$WRITES+),
The parameters of the operation are passed through \verb+args+, which
contains a pointer to each parameter.
If the operation has a result, the last of these parameters is the address
where the result must be placed.

\verb+DoOperation+
must perform the operation, possibly remotely.

\subsection{Translation of operations}
Operations are translated into two routines: one implementing the read
alternatives, and one implementing the write alternatives.
Their parameters are passed as a list of addresses (\verb+DoOperation+ is
responsible for this).
For efficiency, two extra routines may be generated, again one for the
read alternatives and one for the write alternatives, but using the
parameter passing mechanism that is also used for functions.
These versions may always be used (after obtaining the
required locks), except when calling through \verb+DoOperation+.

Nested operations cause a bit of trouble.
Usually, blocking operations on local objects cause a deadlock,
but for a nested operation, this does not have to be the case,
as the outer operation may have other guards.
A setjmp/longjmp implementation would solve this problem, but
cannot be used because in between the setjmp and the longjmp,
space may have been allocated for variables, and we have no way
of freeing this space.

Therefore, the compiler keeps track of which operation calls possibly are
nested.
If the operation is nested, and it would block, \verb+DoOperation+ should
set the \verb+op_flags+ flag appropriately and return.
The calling code will check this and the return sequence will be invoked
when the flag is set.
This ensures that the space allocated for variables will be freed.

\section{Processes}\label{sec:procs}

\subsection{Process type descriptors}
Process type descriptors are used for marshalling parameters during a fork.
They are generated by the compiler, one for each process type.
They have the following structure:
\begin{quote}
\begin{verbatim}
typedef struct sharg {
               /* The numbers in this structure are scaled down
                  if their value becomes too large. */
     double    arg_score;    /* a measure for the number of reads versus
                                number of writes. Negative means more
                                reads than writes.
                             */
     double    arg_naccess;  /* number of accesses. */
     double    arg_uncertainty;
                             /* uncertainty about score: the higher,
                                the more uncertain.
                             */
} sh_args;

typedef struct proc_descr {
     void        (*prc_name)(void **);
     tp_dscr      *prc_func;         /* function descriptor of process */
     int           prc_registration; /* registration number */
     sh_args      *prc_shargs;       /* one for each argument */
     char         *prc_trc_name;     /* process name for tracing */
     int         (*prc_size_args)(void **);
#ifdef PANDA4
     pan_iovec_p (*prc_marshall_args)(pan_iovec_p, void **);
     void        (*prc_unmarshall_args)(void *, void **);
#else
     char       *(*prc_marshall_args)(char *, void **);
     char       *(*prc_unmarshall_args)(char *, void **);
#endif
} prc_dscr;
\end{verbatim}
\end{quote}
\verb+prc_name+ indicates the procedure implementing the process.
it has one parameter: a pointer to a list of addresses of parameters.
\verb+prc_shargs+
is a pointer to an array of \verb+sh_args+
structures,
one element for each parameter,
which contains some usage information about the parameter.
The three function pointers are the usual marshalling entries.
Process type descriptors must be registered to the RTS.
The RTS gives each process type descriptor a system-wide unique key, which is
just an integer.

\subsection{Runtime-system support for processes}\label{sec:rtsproc}
Process descriptors must be registered to the RTS.
The RTS gives each process descriptor a system-wide unique key, which is
just an integer.
For this purpose (and to register other pointers as well), the RTS
provides the following routine:
\begin{quote}
\begin{verbatim}
int m_ptrregister(void *f);
\end{verbatim}
\end{quote}
which can be used to register any pointer that may have to be marshalled.
A unique integer that identifies the pointer is returned.
This routine can be used to register a process descriptor, a function
address, or an object type descriptor.
Also provided is:
\begin{quote}
\begin{verbatim}
void *m_getptr(int i);
\end{verbatim}
\end{quote}
which returns the pointer which was registered earlier and given the
unique integer \verb+i+.
A runtime error occurs if \verb+i+
is not a value ever returned by
\verb+m_ptrregister+.

Apart from these two routines, the only routine required by the
compiler for process support is:
\begin{quote}
\begin{verbatim}
void DoFork(int cpu, prc_dscr *procdscr, void **args);
\end{verbatim}
\end{quote}
which forks the process indicated by \verb+procdscr+, on the
CPU indicated by \verb+cpu+.
The parameters of the Orca process are indicated by \verb+args+,
which contains a pointer to each parameter.

\section{Miscellaneous}\label{sec:misc}
The RTS provides the following routines:
\begin{quote}
\begin{verbatim}
t_integer m_div(t_integer a, t_integer b);
t_longint m_divl(t_longint a, t_longint b);
t_integer m_mod(t_integer a, t_integer b);
t_longint m_modl(t_longint a, t_longint b);
\end{verbatim}
\end{quote}
These routines implement \verb+a/b+ and \verb+a\%b+ on integer types.
A runtime error occurs if \verb+b+ is zero.

For \verb+ABS+, the RTS provides the following routines:
\begin{quote}
\begin{verbatim}
t_integer m_abs(t_integer arg);
t_longint m_labs(t_longint arg);
t_real m_rabs(t_real arg);
t_longreal m_lrabs(t_longreal arg);
\end{verbatim}
\end{quote}

For \verb+CAP+, the RTS provides the following routine:
\begin{quote}
\begin{verbatim}
t_char m_cap(t_char arg);
\end{verbatim}
\end{quote}

For \verb+NCPUS+, the RTS provides the following routine:
\begin{quote}
\begin{verbatim}
t_integer m_ncpus(void);
\end{verbatim}
\end{quote}

For \verb+MYCPU+, the RTS provides the following routine:
\begin{quote}
\begin{verbatim}
t_integer m_mycpu(void);
\end{verbatim}
\end{quote}

For the \verb+CHR+ and \verb+VAL+ primitives, the RTS provides the
following routine:
\begin{quote}
\begin{verbatim}
t_integer m_check(t_integer val, t_integer nenums, char *fn, int ln);
\end{verbatim}
\end{quote}
which results in a runtime error if \verb+val+ is greater than or equal to
\verb+nenums+, and which returns \verb+val+.
The filename and linenumber are provided to produce a sensible error message
in case of a runtime error.

For \verb+ASSERT+, the RTS provides the following routine:
\begin{quote}
\begin{verbatim}
void m_assert(t_boolean e, char *fn, int ln);
\end{verbatim}
\end{quote}
which results in a runtime error if \verb+e+
is zero.

For alias checking, the RTS provides the following routine:
\begin{quote}
\begin{verbatim}
void m_aliaschk(void *a, void *b, tp_dscr *da, tp_dscr *db, char *fn, int ln);
\end{verbatim}
\end{quote}
which results in a runtime error if
\begin{enumerate}
\item
\verb+a+ and \verb+b+ denote the same variable, or
\item
\verb+a+
denotes a component of \verb+b+, or
\item
\verb+b+ denotes a component of \verb+a+.
\end{enumerate}
For scheduling purposes, the compiler generates calls to the following routine:
\begin{quote}
\begin{verbatim}
void m_rts(void);
\end{verbatim}
\end{quote}
It does so at the start of every function/operation/process body,
and in every loop. 
This enables the RTS to do some scheduling.
On systems where scheduling does not have to be provided explicitly,
\verb+m_rts+
could be implemented as a macro with an empty body,
so that it does not cause any overhead.

The RTS also provides the following routine:
\begin{quote}
\begin{verbatim}
void m_trap(int trapno, char *fn, int ln);
\end{verbatim}
\end{quote}
which causes runtime error number \verb+trapno+
to occur.
The current runtime error numbers are defined in the include file
{\em error.h}

For tracing,
the compiler generates calls to the following routine during object type
initialization:
\begin{quote}
\begin{verbatim}
void m_objdescr_reg(tp_descr *obj_d, int n_operations, char *objtype_name);
\end{verbatim}
\end{quote}

For the marshalling of objects, the compiler generates calls to the following
routines for the marshalling of the RTS-dependent part of the object:
\begin{quote}
\begin{verbatim}
int o_rts_nbytes(t_object *o, tp_dscr *d);
#ifdef PANDA4
pan_iovec_p o_rts_marshall(pan_iovec_p p, t_object *o, tp_dscr *d);
void o_rts_unmarshall(void *p, t_object *o, tp_dscr *d);
#else
char *o_rts_marshall(char *p, t_object *o, tp_dscr *d);
char *o_rts_unmarshall(char *p, t_object *o, tp_dscr *d);
#endif
\end{verbatim}
\end{quote}

For storage allocation, the compiler generates calls to the following
routines:
\begin{quote}
\begin{verbatim}
void *m_malloc(size_t sz);
void *m_realloc(void *p, size_t sz);
void m_free(void *);
\end{verbatim}
\end{quote}
These routines act like their C counterparts, but trap if memory could not
be allocated.

Also, the compiler generates calls to score-functions, at the start
and end of each process, for every object declared in the process:
\begin{quote}
\begin{verbatim}
void __Score(void *o, tp_dscr *d,
             double score, double naccess, double uncertainty);
void __Erocs(void *o, tp_dscr *d,
             double score, double naccess, double uncertainty);
\end{verbatim}
\end{quote}
The parameter \verb+score+
is a measure for the number of reads versus
number of writes. Negative means more reads than writes.
The parameter \verb+naccess+ is a measure for the number of accesses,
and \verb+uncertainty+
is an indication of the (un)certainty of \verb+score+:
the higher, the more uncertain.
\end{document}
