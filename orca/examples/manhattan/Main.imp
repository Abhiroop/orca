# 
# NAME:
#     mankrank - Manhattan Krankenweg parallel solver
#
# SYNOPSIS:
#     gax [options] mankrank [ncpus]
#
# DESCRIPTION:
#     The program will solve the Manhattan Krankenweg problem, given a 
#     problem specification.
#
# DIAGNOSTICS:
#     If no run-time errors occurrs the program exits with
#     errorcode 0. All warnings given during execution can
#     be read in the file "Warnings". Error are saved in
#     the file "Errors".
#     Messages, warnings and errors are written in the format:
#     MESSAGE: CPU cpu-nr: [YYYY-MM-DD HH.MM.SS] Message
#     WARNING: CPU cpu-nr: [YYYY-MM-DD HH.MM.SS] Message
#     ERROR: CPU cpu-nr: [YYYY-MM-DD H.MM.SS] Message
#
#     During execution the evolving solution (what is being worked on)
#     will be written to stdout. Every time a better solution is found
#     it is immediatly written. Messages informing the user regarding
#     which phase the program is executing in are also shown.

#    
# FILES:
#     problem.tsp : The default problem specification.
#	This file specifies what nodes are to be used,
#       which distance function, and some control parameters.
#     Solution : This file will contain the final solution
#	when the program is finished.
#     InitialDistribution : Contains the distribution that was best
#                last time the program was run.
#     Errors : Contains all error messages from the program execution
#     Warnings : Contains all warning messages from the program 
#                execution.
#
# VERSION:
#     1.0
#
# AUTHOR:
#     Mattias Forsberg, forsberg@cs.vu.nl (c92matfo@und.ida.liu.se)
#


MODULE IMPLEMENTATION Main;

FROM TspTypes IMPORT
	MoveInfo,
	ProcessorStatusType,
	NodeSelection,
	DistributionChange,
	NodeDistribution;
FROM TspFunctions IMPORT
	AppendString;
FROM CollectionTypes IMPORT
	TourCollection;
FROM PresentationModule IMPORT
	Warning,
	PrintMessageInt,
	PrintMessageReal,
	PrintStatusReport,
	PrintMessage;
FROM LogModule IMPORT
	LogStoreMessageOn;
FROM TspOpt IMPORT
	TspProcess;
FROM Time IMPORT
	SysMilli,
	GetTime,
	Sleep;
FROM InOut IMPORT
	OpenOutputFile,
	CloseOutput;
FROM conversions IMPORT
	IntToString;
FROM Finish IMPORT 
	Finish;

IMPORT IntObject;
IMPORT SpecificationObject;
IMPORT DistributionObject;
IMPORT CommunicationObject;
IMPORT TourCollectionObject;
IMPORT MonitorObject;
IMPORT HashTableObject;


OBJECT JobQueue = NEW GenericJobQueue (TourCollectionObject);

CONST InitialHops = 2;	# Number of initial hops for  distribution job generation




FUNCTION Improve (tc : SHARED TourCollectionObject; 
		  transTable : SHARED HashTableObject; 
	       	  spec : SpecificationObject);
	tour : TourCollection;	# The individual tours of parameter tc
	first_key : string;	# The ID of the tour before improvement
	inf : MoveInfo;		# The info of the transposition table post
	old_val : integer;
BEGIN
	tour := tc$Tours ();
	FOR i IN LB(tour)..UB(tour) DO
		first_key := tour[i]$Id ();
		inf := transTable$Lookup (first_key);
		old_val := tour[i]$Value ();
		IF (inf.valid AND (old_val > inf.val)) THEN
			tour[i]$FromStringInt (inf.move, inf.val);
		ELSE
			tour[i]$Improve ();
			transTable$Insert (first_key, 
				tour[i]$Id (), 
				tour[i]$Value ());
		FI;
	OD;
		
	tc$CreateFromArray (tour, spec);	
END;



#
# The Worker process's purpose is to improve solutions
# generated by the producer and send them on to the
# solution evaluator. 
#
FUNCTION Improver (d : DistributionObject;
		tc : TourCollectionObject;
		level : integer; 
		outQueue : SHARED JobQueue;
		transTable : SHARED HashTableObject;
		spec : SpecificationObject);
	dc : DistributionChange;	# Delta distribution [d1 => d2]
BEGIN
	IF level >= spec$SearchDepth () THEN RETURN; FI;
	d$SetBaseProblem (tc);
	WHILE d$AreThereMoreDistributions () DO
		dc := d$DeltaDistribution ();
		tc$ChangeDistribution (dc);
		Improve (tc, transTable, spec);
		tc$IncreaseLevel ();
		outQueue$AddJob (tc);
		IF tc$Pursue () THEN
			Improver (d, tc, level + 1, 
				outQueue, transTable, spec);
		FI;
		tc$DecreaseLevel ();
		tc$RevertDistributionChange (dc);
	OD;
END;




PROCESS Worker (mon : SHARED MonitorObject;
		inQueue : SHARED JobQueue; 
		outQueue : SHARED JobQueue;
		granularity : integer;
		transTable : SHARED HashTableObject;
		spec : SpecificationObject);
	j : TourCollectionObject;	# Buffer for incomming jobs
	d : DistributionObject;		# Distributor used
BEGIN
	d$Initialize (spec, spec$DeliveryBoys (), improved);
	d$SetStepSize (granularity);
	mon$WorkerStarted ();
	mon$WorkerWait ();
	WHILE inQueue$GetJob (j) DO
		mon$WorkerRecommence ();
		Improver (d, j, InitialHops, outQueue, transTable, spec);
		mon$WorkerWait ();
		mon$WorkerDoneOneJob ();
	OD;
	mon$WorkerDone ();
END;

	



FUNCTION GenerateJobs (d : DistributionObject;
			tc : TourCollectionObject;
			level : integer;
			outQueue : SHARED JobQueue;
			evalQueue : SHARED JobQueue;
			com : SHARED CommunicationObject;
			transTable : SHARED HashTableObject;
			spec : SpecificationObject);
	dc : DistributionChange;	# Delta distribution [d1 => d2]
BEGIN
	IF level >= InitialHops THEN 
		outQueue$AddJob (tc);	
		com$JobProduced ();
		RETURN; 
	FI;
	d$SetBaseProblem (tc);
	WHILE d$AreThereMoreDistributions () DO
		dc := d$DeltaDistribution ();
		tc$ChangeDistribution (dc);
#		Improve (tc, transTable, spec);
		tc$IncreaseLevel ();
		evalQueue$AddJob (tc);
		IF tc$Pursue () THEN
			GenerateJobs (d, tc, level + 1, 
					outQueue, evalQueue, com, transTable, spec);
		FI;
		tc$DecreaseLevel ();
		tc$RevertDistributionChange (dc);
	OD;
END;





#
# The producer makes alternations to the distribution
# of nodes between the deliveryboys and sends the 
# solutions to the worker processes for evaluation.
# The distributions are based on either the initial
# distribution, and later, on previous distributions
# that are good enough. These are returned from the
# evaluator.
#  The producer will stop when one of these two
# conditions are satisfied:
#	1 - Stop signal is sent (via CommunicationObject)
#	2 - The level of the objects is larger then
#           the specified search depth (in the spec-file)
#
PROCESS Producer (com : SHARED CommunicationObject;
		spec : SpecificationObject;
		granularity : integer;
		outQueue : SHARED JobQueue;
		evalQueue : SHARED JobQueue;
		transTable : SHARED HashTableObject);
	distributor : DistributionObject; # Distributor to be used.
	tc : TourCollectionObject;	  # Used for init of distributor
	nd : NodeDistribution;		  # For init of distributor
BEGIN
	com$ProducerStarted ();
	distributor$Initialize (spec, spec$DeliveryBoys (), improved);
	distributor$SetStepSize (granularity);

	nd := distributor$InitialDistribution ();
	tc$Initialize (nd, spec);
	distributor$SetBaseProblem (tc);
	
	GenerateJobs (distributor, tc, 0, outQueue, evalQueue, com, transTable, spec);

	outQueue$NoMoreJobs ();
	com$ProducerDone ();
END;



# MergeTours
#
# MergeTours merges two TCO's together so that the resulting TCO uses
# the best tours of the two participating TCO's.
#
FUNCTION MergeTours (best : SHARED TourCollectionObject; 
		tc : TourCollectionObject);
	t : TourCollection;
	updated : ARRAY[integer 1..4] OF boolean;
	onetrue : boolean;
BEGIN
	# First check if we found something that was better in total
	# than the previous best solution found.
	IF best$Value () > tc$Value () THEN
		best := tc;
		PrintMessage ("Better tour found: ");
		best$Print ();
		RETURN;
	FI;

	# If that was not the case, check if we can improve our solution
	# partially, through partial swaps of TourObjects
	onetrue := false;
	t := tc$Tours ();
	FOR i IN 1..4 DO
		updated[i] := best$SetTourIfBetter (i, t[i]);
		IF updated[i] THEN
			PrintMessageInt ("Partial update: ", i);
		FI;
		onetrue := onetrue OR updated[i];
	OD;
	IF onetrue THEN
		best$Print ();
	FI;

END;




#
# The evaluator does two things:
#	1 - Is the solution better than the best one so far?
#	    Then update the best-variable.
#	2 - Is the solution good enough too be pursued?
#	    Then send it back to the producer so it will be pursued.
#
PROCESS Evaluator (com : SHARED CommunicationObject;
		best : SHARED TourCollectionObject;
		evalJobs : SHARED JobQueue);
	tc : TourCollectionObject;
BEGIN
	com$EvalStarted ();
	WHILE ((com$EvalStatus () /= stopping) AND evalJobs$GetJob (tc)) DO
		com$JobEvaluated ();
		MergeTours (best, tc);
	OD;
	com$EvalDone ();
END;
	



# Finalize
#
# Finalize performs the final steps in order to make the
# solution as good as possible. As of now the process will
#	- Perform full TSP search on parts of the groups
#	  and insert the rest of the nodes to the least cost.
#
PROCESS Finalize (best : TourCollectionObject; 
			result : SHARED TourCollectionObject; 
			spec : SpecificationObject; 
			working : SHARED IntObject;
			transTable : SHARED HashTableObject);
	tspWorking : IntObject;
	nd : NodeDistribution;
	temp_res : TourCollection[1..4];
	time_ms : integer;	# The time-limit for Tsp execution in ms
	first_key : string;	# The hash ID of the original TourObject
	inf : MoveInfo;		# Move info for possible optimal move
BEGIN
	PrintMessage ("Final optimization has started.");
	nd := best$Distribution ();
	time_ms := TRUNC (FLOAT (300000) / FLOAT (NCPUS ()));
	IF time_ms < 20000 THEN
		time_ms := 20000;
	FI;
	PrintMessageInt ("Time: ", time_ms);

	FOR i IN LB(temp_res)..UB(temp_res) DO
		tspWorking$assign (1);
		temp_res[i]$Initialize (nd[i], spec);
		first_key := temp_res[i]$Id ();
		FORK TspProcess (temp_res[i], 
				temp_res[i]$Nodes_Set (), 
				spec, 
				0,
				NCPUS () - 1,
				tspWorking,
				time_ms) ON (MYCPU ());
		tspWorking$AwaitValue (0);
		PrintMessageInt ("Group optimized: ", i);

		inf := transTable$Lookup (first_key);
		IF (inf.valid AND (inf.val < temp_res[i]$Value ())) THEN
			temp_res[i]$FromStringInt (inf.move, inf.val);
		ELSE
			transTable$Insert (first_key, 
					temp_res[i]$Id (), 
					temp_res[i]$Value ());
		FI;		
	OD;

	result$CreateFromArray (temp_res, spec);
	working$dec ();

END;



PROCESS ExecutionControl (running : SHARED IntObject;
		best : SHARED TourCollectionObject;
		granularity : integer;			# Nodes moved/distr
		transTable : SHARED HashTableObject;	# Transposition table
			spec : SpecificationObject);
	jobs_improved : integer;	# Number of jobs improved
	lastWorkerStarted : boolean;	# True: producer-finished && 
					#	worker started in it's place
	workersStopped : boolean;	# True: All workers stopped
	com : CommunicationObject;	# Communicate with procs
	mon : ARRAY [integer 0..(NCPUS() - 1)] OF MonitorObject;	
	newJobs,			# Queue for produced jobs
	evalJobs : JobQueue;		# Queue for jobs to be evaluated
	firstWorker,			# Processor nr for first initial worker process
	prodProcessor,			# Processor nr for producer
	evalProcessor : integer;	# Processor nr for evaluator
	programRunning : boolean;	# Determines when to finish
	start_t : integer;		# Starting time of this process
	imp_spd_mes_printed : boolean;	# True when improvement speed mess
					# has been printed.
BEGIN
	programRunning := true;
	lastWorkerStarted := false;
	IF NCPUS () > 2 THEN
		prodProcessor := 0;
		firstWorker := 1;
	ELSE
		prodProcessor := 0;
		IF NCPUS () = 1 THEN
			firstWorker := 0;
		ELSE
			firstWorker := 1;
		FI;
	FI;
	evalProcessor := 0;
	start_t := SysMilli ();
	imp_spd_mes_printed := false;


	# Fork all the processes.
	FORK Producer (com, spec, granularity, newJobs, evalJobs, transTable) 
		ON (prodProcessor);
	IF NCPUS () = 1 THEN
		FORK Worker (mon[MYCPU()], newJobs, evalJobs, 
			granularity, transTable, spec) 
			ON (MYCPU());
	ELSE
		FOR i IN (firstWorker)..(NCPUS() - 1) DO
			FORK Worker (mon[i], newJobs, evalJobs, 
				granularity, transTable, spec) 
				ON (i);
		OD;
	FI;
	FORK Evaluator (com, best, evalJobs) ON (evalProcessor);


	WHILE programRunning DO

		Sleep (10, 0);

		# Count how many jobs have been improved by the workers.
		jobs_improved := 0;
		FOR i IN LB(mon)..UB(mon) DO
			jobs_improved +:= mon[i]$JobsDone ();
		OD;


		# Check tour consistency if we are in debug mode.
		IF spec$DebugMode () THEN
			IF NOT best$Consistent () THEN
				Warning ("The tour is not consistent!");
			FI;
		FI;

		
		# Control program execution. 
		workersStopped := true;
		FOR i IN LB(mon)..UB(mon) DO
			workersStopped := workersStopped AND 
					  (NOT mon[i]$WorkerActive ());
		OD;


		PrintStatusReport (com$ProducerStatus (),
				com$EvalStatus (),
				com$JobsProduced (),
				jobs_improved,
				com$JobsEvaluated (),
				TRUNC (best$Value ()));
				

		# Load balancing

		# Start a new worker when producer is done
		IF (NOT lastWorkerStarted) AND 
		   (com$ProducerStatus () = stopped) THEN
			PrintMessage ("Producer has stopped producing");
			lastWorkerStarted := true;
			FORK Worker (mon[prodProcessor], newJobs, evalJobs, 
				granularity, transTable, spec) 
				ON (prodProcessor);
		FI;

		# Control the evaluator job queue and thus the evaluator
		IF workersStopped THEN
			IF NOT imp_spd_mes_printed THEN
				PrintMessage ("All workers stopped.");
				PrintMessageReal ("Improvement speed (jobs/sec): ", 
					FLOAT (jobs_improved) / (FLOAT ((SysMilli () - start_t) * 1000)));
				imp_spd_mes_printed := true;
			FI;
			evalJobs$NoMoreJobs ();
			com$StopEval ();
		FI;

		# Check if all processes have finished
		programRunning := (NOT (com$ProducerStatus () = stopped)) OR
				  (NOT (com$EvalStatus () = stopped)) OR
				  (NOT workersStopped);
	OD;

	PrintMessageReal ("Evaluation speed (TCO/sec): ",
		FLOAT (com$JobsEvaluated ()) / FLOAT ((SysMilli () - start_t) * 1000));
	running$dec ();
END;



PROCESS OrcaMain ();
	spec : SpecificationObject;
	temp,
	best : TourCollectionObject;
	distributor : DistributionObject;
	phase_1_start_t,
	phase_1_stop_t,
	total_start_t,
	total_stop_t : integer;
	running : IntObject;	
	transTable : HashTableObject;	# Global transposition table
BEGIN
	PrintMessage ("Started!");
	total_start_t := GetTime ();

	# Read and print problem specification
	spec$FromFile ("./problem.tsp");
	spec$Print ();

	# Initialize distributor (file access)
	distributor$Initialize (spec, spec$DeliveryBoys (), improved);

	# Create the first tour and calculate it's value.
	best$Load ("InitialDistribution", spec);
	Improve (best, transTable, spec);
	best$Print ();

	# Search phase starting
	phase_1_start_t := GetTime ();
	running$assign (1);
	FORK ExecutionControl (running, best, 1, transTable, spec);
	running$AwaitValue (0);
	phase_1_stop_t := GetTime ();

	# Finalization phase starting
	running$assign (1);
	FORK Finalize (best, temp, spec, running, transTable);
	running$AwaitValue (0);
	MergeTours (best, temp);


	total_stop_t := GetTime ();


	PrintMessage ("Final solution: ");
	best$Print ();

	IF NOT OpenOutputFile ("Solution") THEN
		Warning ("Could not open output file Solution");
	ELSE
		best$Print ();
		CloseOutput ();
	FI;


	# Save distribution so we can start there next time.
	best$Save ("InitialDistribution");
	
	LogStoreMessageOn (
		AppendString ("No of CPU's: ",
		AppendString (IntToString (NCPUS ()),
		AppendString ("  Search depth: ",
		AppendString (IntToString (spec$SearchDepth ()),
		AppendString ("  Phase 1: ",
		AppendString (IntToString (phase_1_stop_t - phase_1_start_t),
		AppendString ("  Total: ",
		AppendString (IntToString (total_stop_t - total_start_t), ".")))))))),
		"Time", 
		MYCPU ());

	IF NOT best$Consistent () THEN
		Warning ("OrcaMain: Final tour NOT consistent");
	FI;


	PrintMessage ("Program exited in a normal way");
	Finish ();
END;



END;



