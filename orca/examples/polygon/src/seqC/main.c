/*############################################################################*/
/*####   main.c :  overlay calculator  (beterTwoSortLOSDOverlay)          ####*/
/*##                                                                        ##*/


/*----------------------------------------------------------------------------*/
/* Includes.                                                                  */
/*----------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include "module/syscall.h"

#include "Box.h"

/*----------------------------------------------------------------------------*/
/* Constants.                                                                 */
/*----------------------------------------------------------------------------*/

#define  NBR_OF_INP_COOR  4    /* Number of coordinates to form a box. */
#define  MAX_MSG          160  /* Maximum size of a message to screen */

/*----------------------------------------------------------------------------*/
/* Types.                                                                     */
/*----------------------------------------------------------------------------*/

typedef enum { FALSE, TRUE }  Boolean;

typedef enum { NERR, ERR }  ExitError;

/*----------------------------------------------------------------------------*/
/* Functional marcros.                                                        */
/*----------------------------------------------------------------------------*/

#define   maxInt( a, b )  (((a) > (b)) ?  (a) :  (b))
#define   minInt( a, b )  (((a) < (b)) ?  (a) :  (b))

/*----------------------------------------------------------------------------*/
/* Local Function prototypes. (in order of appearance)                        */
/*----------------------------------------------------------------------------*/

int      main( int, char*[] );
void     getInputValues( int, char*[], char*[], char*[], char*[], Box* );
void     readList( char [], BoxList* );
void     qSortBoxListCorner0XY( BoxList, int );
Boolean  readBox( FILE*, Box* );
void     writeBox( FILE*, Box );
Boolean  resultingBox( Box, Box , Box* );
void     error( char[] );

/*----------------------------------------------------------------------------*/
/* main()                                                                     */
/*----------------------------------------------------------------------------*/

 int
main(
  int    argc,   /* Argument count. */
  char*  argv[]  /* Argument list. */
) {
  char*    aFile;         /* Name of the "aFile". */
  BoxList  aList;         /* Contains boxes from the file "aFile" */
  char*    bFile;         /* Name of the "bFile". */
  BoxList  bList;         /* Contains boxes from the file "bFile" */
  Box      mainBox;       /* The surrounding/outer box */
  BoxList  p;             /* Walks trough the aList. */
  BoxList  q;             /* Is one step behind p to be able to delete. */
  Box      resultBox;     /* Box being generated by overlay. */
  char*    resultFile;    /* Name of the "resultFile". */
  FILE*    resultFp;      /* Points to resultFile. */
# ifdef TIMING
      unsigned long timeStart;     /* To keep track of spend time. */
      unsigned long timeAfterRead; /* To keep track of spend time. */
      unsigned long timeAfterSort; /* To keep track of spend time. */
      unsigned long timeEnd;       /* To keep track of spend time. */
# endif

    getInputValues(argc, argv, &aFile, &bFile, &resultFile, &mainBox);


#   ifdef TIMING
        timeStart = sys_milli();
#   endif
    readList(aFile, &aList);
    readList(bFile, &bList);
#   ifdef TIMING
        timeAfterRead = sys_milli();
#   endif

    qSortBoxListCorner0XY(aList, listLength(aList));
    qSortBoxListCorner0XY(bList, listLength(bList));
#   ifdef TIMING
        timeAfterSort = sys_milli();
#   endif

#   ifndef NO_OUTPUT
        resultFp = fopen(resultFile, "w");
        writeBox(resultFp, mainBox);    /* Write the surrounding box. */
#   endif

    while (! isEmptyBoxList(bList)) {

	p = aList;
	q = NULL;
	while ((! isEmptyBoxList(p)) && (! noMoreBoxSurface(bList->box))){
            if (resultingBox(bList->box, p->box, &resultBox)) {
#               ifndef NO_OUTPUT
		    writeBox(resultFp, resultBox);
#               endif
		calcBoxSurface(&resultBox);
		substractFromBoxSurface(&(p->box), resultBox);
		substractFromBoxSurface(&(bList->box), resultBox);
		if (noMoreBoxSurface(p->box)) {
		    delNextBoxFromList(&aList, q);
		    if (q == NULL) {
			p = aList;
		    } /* if */
		    else {
			p = q->next;
		    } /* else */
		} /* if */
		else {
		    q = p;
		    p = p->next;
		} /* else */
	    } /* if */
	    else {
		q = p;
		p = p->next;
	    } /* else */
	} /* while */

	delFirstBoxFromList(&bList);
    } /* while */

#   ifndef NO_OUTPUT
        fclose(resultFp);
#   endif
#   ifdef TIMING
        timeEnd = sys_milli();
#       ifndef NO_OUTPUT
            printf("total time = %ld = read:%ld + sort:%ld + calc/write:%ld\n",
	           timeEnd-timeStart, timeAfterRead-timeStart,
	       timeAfterSort-timeAfterRead, timeEnd-timeAfterSort);
#       else
            printf("total time = %ld = sort:%ld + calc:%ld\n",
	           timeEnd-timeAfterRead, timeAfterSort-timeAfterRead,
		   timeEnd-timeAfterSort);
#       endif
#   endif

    return( NERR );
} /* main */

/*----------------------------------------------------------------------------*/
/* getInputValues()                                                           */
/*----------------------------------------------------------------------------*/

 void
getInputValues(
  int    argc,         /* Argument count. */
  char*  argv[],       /* Argument list. */
  char*  aFile[],  /* File name of a file with boxes. */
  char*  bFile[],   /* File name of the other file with boxes. */
  char*  resultFile[], /* File name of the other file with boxes. */
  Box*   mainBox       /* Contains sizes of the outer box. */
) {
  Box    checkBox;        /* To check wether files have same outer box size. */
  char   errm[MAX_MSG];   /* Contains a message if erroneous input is given. */
  FILE*  fp;              /* Points to a file. */
  char   usage[MAX_MSG];  /* How to use this program (which options). */
  void*  tmpMB;


    sprintf(usage, "usage:  %s %s %s ", argv[0], "boxFile1", "boxFile2");

    if (argc < 4) {
        sprintf(errm, "%s: %s\n\n%s", argv[0], "No files specified", usage);
        error(errm);
    }

    *aFile = argv[1];
    *bFile = argv[2];
    *resultFile = argv[3];

    if (argc > 4) {
	tmpMB = malloc(atoi(argv[4]) * 1000000);
	free(tmpMB);
    }

    if ((fp= fopen(*aFile, "r")) == NULL) {
        sprintf(errm, "%s: %s%s%s\n\n%s", argv[0], "File \"", *aFile,
                "\" not found or not readable", usage);
        error(errm);
    }
    if (! readBox(fp, mainBox)) {
        sprintf(errm, "%s: %s%s%s\n\n%s", argv[0], "File \"", *aFile,
                "\" has wrong format.", usage);
        error(errm);
    }

    if ((fp= fopen(*bFile, "r")) == NULL) {
        sprintf(errm, "%s: %s%s%s\n\n%s", argv[0], "File \"", *bFile,
                "\" not found or not readable", usage);
        error(errm);
    }
    if (! readBox(fp, &checkBox)) {
        sprintf(errm, "%s: %s%s%s\n\n%s", argv[0], "File \"", *bFile,
                "\" has wrong format.", usage);
        error(errm);
    }

    if ((fp= fopen(*resultFile, "w")) == NULL) {
        sprintf(errm, "%s: %s%s%s\n\n%s", argv[0], "File \"", *resultFile,
                "\" not found or not writeable", usage);
        error(errm);
    }

    if (   (mainBox->corner0.x != checkBox.corner0.x)
        || (mainBox->corner0.y != checkBox.corner0.y)
        || (mainBox->corner2.x != checkBox.corner2.x)
        || (mainBox->corner2.y != checkBox.corner2.y) )
    {
        sprintf(errm, "%s: %s\n\n%s", argv[0],
                "Files contain different outer boxes", usage);
        error(errm);
    } /* if */

} /* getInputValues() */

/*----------------------------------------------------------------------------*/
/* readList()                                                                 */
/*----------------------------------------------------------------------------*/

 void
readList(
  char          filename[],    /* File to read the boxes from. */
  BoxList*      list           /* To put boxes in, read from the file. */
) {
  Box    box;  /* Box that has been read and put in the list */
  FILE*  fp;   /* File to read the boxes from. */

    fp = fopen(filename, "r");
    readBox(fp, &box);    /* Don't include the outer box*/

    initBoxList(list);
    while (readBox(fp, &box)) {
	calcBoxSurface(&box);
        addBoxToList(box, list);
    } /* while */
} /* readList*/

/*----------------------------------------------------------------------------*/
/* qSortBoxListCorner0XY()                                                    */
/*----------------------------------------------------------------------------*/

 void
qSortBoxListCorner0XY(
  BoxList  boxList,  /* List to sort. */
  int      length    /* Length of the list to sort. */
) {
  int      i;     /* Loop variable. */
  BoxList  last;  /* To keep track of the end of the first sublist. */
  int      n;     /* The length of the first sublist. */
  BoxList  p;     /* Walks trough the whole list. */
  Box      swap;  /* Helps with swapping. */
    
    if (length <= 1) {
	return;    /* End of recursion */
    } /* if */

    last = boxList;
    n = 1;
    for(i = 0, p = last->next; (i < (length - 1)); i++, p = p->next) {
	if (   (p->box.corner0.x < boxList->box.corner0.x)
	    || (   (p->box.corner0.x == boxList->box.corner0.x)
		&& (p->box.corner0.y < boxList->box.corner0.y)
	       )
	) {
	    last = last->next;
	    n++;
	    swap = p->box;
	    p->box = last->box;
	    last->box = swap;
	} /* if */
    } /* for */
    swap = last->box;
    last->box = boxList->box;    /* "last"-item is now on it's place. */
    boxList->box = swap;

    qSortBoxListCorner0XY(boxList, n - 1);
    qSortBoxListCorner0XY(last->next, (length - n));
} /* qSortBoxListCorner0XY */

/*----------------------------------------------------------------------------*/
/* readBox()                                                                  */
/*----------------------------------------------------------------------------*/

 Boolean
readBox(
  FILE*  fp,  /* The stream to read from. */
  Box*   box  /* The box which has been read. */
) {
    return (fscanf(fp, "%d%d%d%d", &(box->corner0.x), &(box->corner0.y),
		   &(box->corner2.x), &(box->corner2.y)
	    ) == NBR_OF_INP_COOR
           );
} /* readBox */

/*----------------------------------------------------------------------------*/
/* writeBox()                                                                 */
/*----------------------------------------------------------------------------*/

 void
writeBox(
  FILE* fp,  /* The stream to write to. */
  Box   box  /* To be written. */
) {
    fprintf(fp, "%d\t%d\t\t%d\t%d\n", box.corner0.x, box.corner0.y,
             box.corner2.x, box.corner2.y);
} /* writeBox */


/*----------------------------------------------------------------------------*/
/* resultingBox()                                                             */
/*----------------------------------------------------------------------------*/

 Boolean
resultingBox(
  Box   checkBox,
  Box   againstBox,
  Box*  resultBox
) {
    if (   (checkBox.corner0.x < againstBox.corner2.x)
	&& (checkBox.corner2.x > againstBox.corner0.x)
        && (checkBox.corner0.y < againstBox.corner2.y)
	&& (checkBox.corner2.y > againstBox.corner0.y)
    ) {
	resultBox->corner0.x = maxInt(checkBox.corner0.x, againstBox.corner0.x);
	resultBox->corner2.x = minInt(checkBox.corner2.x, againstBox.corner2.x);
	resultBox->corner0.y = maxInt(checkBox.corner0.y, againstBox.corner0.y);
	resultBox->corner2.y = minInt(checkBox.corner2.y, againstBox.corner2.y);

	return TRUE;
    } /* if */

    return FALSE;

} /* resultingBox */

/*----------------------------------------------------------------------------*/
/* error()                                                                    */
/*----------------------------------------------------------------------------*/

 void
error(
  char  message[]  /* Message to put on stderr. */
) {
    fprintf(stderr,"%s\n\n", message);
    exit(ERR);
} /* error */
