/*############################################################################*/
/*####   main.c :  box generator                                          ####*/
/*##                                                                        ##*/

/*                                                                            */
/* This program produces a box filled with randomly generated boxes. With no  */
/* empty spaces between the boxes.                                            */
/*                                                                            */
/* The boxes are generated by expansion. This means that every box starts as  */
/* a 1 x 1 box and than each box will in turn grow a bit in a random          */
/* direction. The expanding of a box stops when all its sides are blocked by  */
/* other box-sides. If holes are left at the end then a new 1 x 1 box will be */
/* defined in that hole, and it will follow the 'expand-procedure'. This is   */
/* done until all holes have vanished.                                        */
/*                                                                            */
/* Output:                                                                    */
/*    The output is sent to standard output and will have the following form: */
/*        <x,y coordinates first corner and third corner of the outer box>    */
/*        <x,y coordinates first corner and third corner of the 1st box>      */
/*        <x,y coordinates first corner and third corner of the 2nd box>      */
/*                               |                                            */
/*                               |                                            */
/*        <x,y coordinates first corner and third corner of the n_th box>     */
/*                                                                            */
/* Log:                                                                       */
/*     7 Nov 1994:                                                            */
/*                                                                            */

/*----------------------------------------------------------------------------*/
/* Includes.                                                                  */
/*----------------------------------------------------------------------------*/

#include <time.h>
#include <stdio.h>
#include <string.h>

#include "Bitmap.h"
#include "Boolean.h"
#include "Box.h"

/*----------------------------------------------------------------------------*/
/* Constants.                                                                 */
/*----------------------------------------------------------------------------*/

#define  MAX_LIST_SIZE  100
#define  TIMES2TRY        4
#define  MAX_MSG        160

/*----------------------------------------------------------------------------*/
/* Types.                                                                     */
/*----------------------------------------------------------------------------*/

typedef enum { NERR, ERR }  ExitError;

/*----------------------------------------------------------------------------*/
/* Function prototypes (in order of appearance).                              */
/*----------------------------------------------------------------------------*/

 int
main(
	int   argc,  /* Argument count. */
	char* argv[] /* Argument list. */
);

 void
getInputValues(
  int      argc,         /* Argument count. */
  char*    argv[],       /* Argument list. */
  Box*     mainBox,      /* Box will be filled with -zx and -zy values. */
  int*     nrOfBoxesIsh, /* Will be filled with -n value. */
  int*     maxSurf,      /* Will be filled with -m value. */
  int*     scaleX,       /* Will be filled with -cx value. */
  int*     scaleY,       /* Will be filled with -cy value. */
  int*     seed          /* Will be filled with -s value or with time. */
);

 Boolean
addFlatBox(
  BoxArray boxArray, /* Array to add the flat box to. */
  int      index,    /* Place in the boxArray to put the flat box. */
  Bitmap   bm,       /* To scratch the flat box's position on. */
  int      pointX,   /* X coordinate where the flat box will be placed.*/
  int      pointY    /* Y coordinate where the flat box will be placed.*/
);

 FreeSides
pickRandomSide(
  Box*   box,     /* Box to pick side from. */
  Box    mainBox, /* To check if the picked side is not on the edge. */
  Bitmap bm,      /* To check whether the picked side is a free one. */
  int    maxSurf  /* To check if the box won't get too large. */
);

 void
expandBox(
  Box*      box,  /* The box to be expanded. */
  FreeSides side, /* The side in which direction it should expand. */
  Bitmap    bm    /* To scratch on what space the expanded box takes. */
);

 Boolean
findHole(
  Bitmap bm,    /* To search in for a hole. */
  Box    mainB, /* To know the bounds of the Bitmap bm */
  int*   holeX, /* If hole was found? the x-coordinate :. */
  int*   holeY  /* If hole was found? the y-coordinate :. */
);

 void
writeBoxes(
  BoxArray boxArray,  /* The boxArray to be written. */
  int      nrOfBoxes, /* Number of boxes of the boxArray to be written. */
  int      scaleX,    /* The x-scale to convert the sizes to.  */
  int      scaleY     /* The y-scale to convert the sizes to. */
);

 void
writeBox(
  Box box,    /* The box to be written. */
  int scaleX, /* The x-scale to convert the sizes to. */
  int scaleY  /* The y-scale to convert the sizes to. */
);

 void
error(
  char  message[] /* Message to put on stderr. */
);


/*----------------------------------------------------------------------------*/
/* main()                                                                     */
/*----------------------------------------------------------------------------*/

 int
main(
  int   argc,  /* Argument count. */
  char* argv[] /* Argument list. */
) {
  int       activeLength; /* Number of boxes in boxArray that can expand. */
  Bitmap    bm;           /* To mark which space is taken by boxes. */
  Box*      boxP;         /* Is currently tried to be expanded. */
  BoxArray  boxArray;     /* Array of boxes which can be expanded. */
  int       boxNumber;    /* The number of the box to be expanded. */
  int       holeX;        /* X coordinate of a hole. */
  int       holeY;        /* Y coordinate of a hole. */
  int       i;            /* Loop variable. */
  Box       mainBox ;     /* Contains the sizes of the outer box. */
  int       maxSurf;      /* Maximal surface of a box. */
  int       nrOfBoxesIsh; /* Initial number of boxes to expand. */
  int       nrOfBoxes;    /* Current number of boxes in 'boxArtray'. */
  int       realLength;   /* Size of the boxArray allocated. */
  int       scaleX;       /* The x-scaling factor to scale afterwards with. */
  int       scaleY;       /* The y-scaling factor to scale afterwards with. */
  int       seed;         /* Seed for the random generator */
  FreeSides side;         /* Side which is going to be expand (if not NONE).*/

    getInputValues(argc, argv, &mainBox, &nrOfBoxesIsh, &maxSurf, &scaleX,
                   &scaleY, &seed);

    if (! initBitmap(&bm, boxLengthX(mainBox), boxLengthY(mainBox))) {
	error("Allocation failed");
    } /* if */

    nrOfBoxes = nrOfBoxesIsh;
    realLength = (int)((float)nrOfBoxes * 1.10);
    if (! initBoxArray(&boxArray, (int)((float)nrOfBoxes * 1.10))) {
	error("Allocation failed");
    } /* if */
    activeLength = nrOfBoxes;

    srandom(seed);

    for (i=0; (i < nrOfBoxes); i++) {
        for (;! addFlatBox(boxArray, i, bm, (random() % boxLengthX(mainBox)),
                           (random() % boxLengthY(mainBox)));
	) {
	    /* Look for free spot to put box on. */
        } /* for */
    } /* for i */

    while (activeLength) {
        boxNumber = random() % activeLength;
        boxP = getBox(boxArray, boxNumber);
        side = pickRandomSide(boxP, mainBox, bm, maxSurf);
        if (side != NONE) {
            expandBox(boxP, side, bm);
        } /* if */
        else {
	    swapBoxes(boxArray, boxNumber, activeLength - 1);
	    activeLength--;

            if (! activeLength) {
		  /* Swap, to prevent the filled holes from being in order: */
		swapBoxes(boxArray, 0, (random() % nrOfBoxes));

		if (findHole(bm, mainBox, &holeX, &holeY)) {
		    activeLength++;
		    nrOfBoxes++;
		    if (realLength < nrOfBoxes) {
			realLength = 1 + (int)((float)realLength * 1.05);
			if (! resizeBoxArray(&boxArray, realLength)) {
			    error("Allocation failed");
			} /* if */
		    } /* if */
	            swapBoxes(boxArray, activeLength - 1, nrOfBoxes - 1);
                    addFlatBox(boxArray, activeLength - 1, bm, holeX, holeY);
                } /* if */
            } /* if */
        } /* else */
    } /* while */

    setlinebuf(stdout);    /* For direct pipelining */
    writeBox(mainBox, scaleX, scaleY);
    writeBoxes(boxArray, nrOfBoxes, scaleX, scaleY);

    fclose(stdout);

    freeBitmap(&bm, boxLengthX(mainBox), boxLengthY(mainBox));
    return( NERR );
} /* main */

/*----------------------------------------------------------------------------*/
/* getInputValues()                                                           */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Input:                                                                     */
/*    The options that can be given are:                                      */
/*                                                                            */
/*        -zx sizeX                                                           */
/*            Defines the x size of the outer box. sizeX must be a integer.   */
/*                                                                            */
/*        -zy sizeY                                                           */
/*            Defines the y size of the outer box. sizeY must be a integer.   */
/*                                                                            */
/*        -n nrOfBoxesIsh                                                     */
/*            Gives the number of boxes to start with. The number of boxes    */
/*            after generation can be larger due to holes between boxes       */
/*            during generation. nrOfBoxesIsh must be a integer.              */
/*                                                                            */
/*        -m maxSurface                                                       */
/*            This option will limit the surface of each box to maxSurface.   */
/*            There is no limit if this option is omitted. maxSurface must be */
/*            an integer.                                                     */
/*                                                                            */
/*        -cx scaleX                                                          */
/*            The scaling will be done after expansion. Before the scaling    */
/*            the minimal size of a x-box-side will be 1. scaleX must be an   */
/*            integer.                                                        */
/*                                                                            */
/*        -cy scaleY                                                          */
/*            The scaling will be done after expansion. Before the scaling    */
/*            the minimal size of a y-box-side will be 1. scaleY must be an   */
/*            integer.                                                        */
/*                                                                            */
/*        -s seedNumber                                                       */
/*            If this option is present it will give "seedNumber" as seed     */
/*            to the random generator instead of the time (in seconds).       */
/*                                                                            */


 void
getInputValues(
  int      argc,         /* Argument count. */
  char*    argv[],       /* Argument list. */
  Box*     mainBox,      /* Box will be filled with -zx and -zy values. */
  int*     nrOfBoxesIsh, /* Will be filled with -n value. */
  int*     maxSurf,      /* Will be filled with -m value. */
  int*     scaleX,       /* Will be filled with -cx value. */
  int*     scaleY,       /* Will be filled with -cy value. */
  int*     seed          /* Will be filled with -s value or with time. */
) {
  char errm[MAX_MSG];  /* Contains a message if erroneous input is given. */
  int  i;              /* Loop variable */
  char usage[MAX_MSG]; /* How to use this program (which options) */

    sprintf(usage, "usage:  %s %s %s %s %s\n    %s %s %s", argv[0],
	    "-zx sizeX", "-zy sizeY", "-n nrOfBoxesIsh", "[-m maxSurface]",
	    "[-cx scaleX]", "[-cy scaleY]", "[-s seedNumber]");
    mainBox->corner0.x = 0;
    mainBox->corner0.y = 0;
    mainBox->corner2.x = -1;
    mainBox->corner2.y = -1;
    *nrOfBoxesIsh = 0;
    *maxSurf = 0;
    *scaleX = 1;
    *scaleY = 1;
    *seed = time(NULL);

    if (argc < ((2 * 3) + 1)) {
        sprintf(errm, "%s:  %s\n\n%s", argv[0], "Not enough arguments", usage);
        error(errm);
    } /* if */

    for (i=1; (i < argc); i++) {
        if ( strncmp("-zx", argv[i], 3) == 0) {
	    i++;
            if (i >= argc) {
                sprintf(errm, "%s:  %s\n\n%s", argv[0],
			"Missing argument at the end", usage);
                error(errm);
            } /* if */
            mainBox->corner2.x = atoi(argv[i]) - 1;
        } /* if */
        else if ( strncmp("-zy", argv[i], 3) == 0) {
	    i++;
            if (i >= argc) {
                sprintf(errm, "%s:  %s\n\n%s", argv[0],
			"Missing argument at the end", usage);
                error(errm);
            } /* if */
            mainBox->corner2.y = atoi(argv[i]) - 1;
        } /* else if */
        else if ( strncmp("-m", argv[i], 2) == 0) {
	    i++;
            if (i >= argc) {
                sprintf(errm, "%s:  %s\n\n%s", argv[0],
			"Missing argument at the end", usage);
                error(errm);
            } /* if */
            *maxSurf = atoi(argv[i]);
        } /* else if */
        else if ( strncmp("-n", argv[i], 2) == 0) {
	    i++;
            if (i >= argc) {
                sprintf(errm, "%s:  %s\n\n%s", argv[0],
			"Missing argument at the end", usage);
                error(errm);
            } /* if */
            *nrOfBoxesIsh = atoi(argv[i]);
        } /* else if */
        else if ( strncmp("-cx", argv[i], 3) == 0) {
	    i++;
            if (i >= argc) {
                sprintf(errm, "%s:  %s\n\n%s", argv[0],
			"Missing argument at the end", usage);
                error(errm);
            } /* if */
            *scaleX = atoi(argv[i]);
        } /* else if */
        else if ( strncmp("-cy", argv[i], 3) == 0) {
	    i++;
            if (i >= argc) {
                sprintf(errm, "%s:  %s\n\n%s", argv[0],
			"Missing argument at the end", usage);
                error(errm);
            } /* if */
            *scaleY = atoi(argv[i]);
        } /* else if */
        else if ( strncmp("-s", argv[i], 2) == 0) {
	    i++;
            if (i >= argc) {
                sprintf(errm, "%s:  %s\n\n%s", argv[0],
			"Missing argument at the end", usage);
                error(errm);
            } /* if */
            *seed = atoi(argv[i]);
        } /* else if */
        else {
            sprintf(errm, "%s:  %s %s\n\n%s", argv[0], "Unknown option:",
		    argv[i], usage);
            error(errm);
        } /* else */
    } /* for i */

    if ((mainBox->corner2.x < 0) || (mainBox->corner2.y < 0)) {
        sprintf(errm, "%s:  %s", argv[0],
                "Box-size values to small or not present.");
        error(errm);
    } /* if */

    if ((*scaleX == 0) || (*scaleY == 0)) {
        sprintf(errm, "%s:  %s", argv[0],
                "Scale-values may not be zero.");
        error(errm);
    } /* if */

    if (*nrOfBoxesIsh <= 0) {
        sprintf(errm, "%s:  %s", argv[0],
                "Number-of-boxes(ish) value too small or not present.");
        error(errm);
    } /* if */
    if (*nrOfBoxesIsh > (boxLengthX(*mainBox) * boxLengthY(*mainBox))) {
        sprintf(errm, "%s:  Number-of-boxes(ish) too large.", argv[0]);
        error(errm);
    } /* if */

    if (*maxSurf < 0) {
        sprintf(errm, "%s:  %s", argv[0],
            "Wrong maximum surface value (-m 0 means unlimited)");
        error(errm);
    } /* if */
    if (*maxSurf == 0) {
        *maxSurf = boxLengthX(*mainBox) * boxLengthY(*mainBox);
    } /* if */
} /* getInputValues */

/*----------------------------------------------------------------------------*/
/* addFlatBox()                                                               */
/*----------------------------------------------------------------------------*/

 Boolean
addFlatBox(
  BoxArray boxArray, /* Array to add the flat box to. */
  int      index,    /* Place in the boxArray to put the flat box. */
  Bitmap   bm,       /* To scratch the flat box's position on. */
  int      pointX,   /* X coordinate where the flat box will be placed.*/
  int      pointY    /* Y coordinate where the flat box will be placed.*/
) {
  Box* pBox; /* The flat box that will be inserted. */

    if (isBitOn(bm, pointX, pointY)) {
        /* This coordinate is already taken. */
        return FALSE;
    } /* if */
    else {
        pBox = allocBox();
        pBox->corner0.x = pointX;
        pBox->corner0.y = pointY;
        pBox->corner2.x = pointX;
        pBox->corner2.y = pointY;
        turnSideFree(&(pBox->freeSides), ALL);

        addBox(boxArray, index, pBox);

        turnBitOn(bm, pointX, pointY);

        return TRUE;
    } /* else */
} /* addFlatBox */

/*----------------------------------------------------------------------------*/
/* pickRandomSide()                                                           */
/*----------------------------------------------------------------------------*/

 FreeSides
pickRandomSide(
  Box*    box,     /* Box to pick side from. */
  Box     mainBox, /* To check if the picked side is not on the edge. */
  Bitmap  bm,      /* To check whether the picked side is a free one. */
  int     maxSurf  /* To check if the box won't get too large. */
) {
  int i;    /* Loop variable */
  int ix;   /* Loop variable */
  int iy;   /* Loop variable */
  int side; /* Going to be returned. */

    for (i=0; ; i++) {
        if (! isSideFree(box->freeSides, ALL)) {
            /* No free side. */
            return (NONE);
        } /* if */

        if (i < TIMES2TRY) {
            /* Try 'TIMES2TRY' times a random side. */
            side = randomSide();
        } /* if */
        else {
            /* If random tries didn't work try sides subsequent. */
            side = nextSide(side);
        } /* else */

        if (isSideFree(box->freeSides, side)) {
            /* Check if side is still free. */
            switch(side) {
                case LEFT:
                    if (box->corner0.x <= mainBox.corner0.x) {
                        turnSideNotFree(&(box->freeSides), LEFT);
                    } /* if */
                    else {
                        for (iy=box->corner0.y; (iy <= box->corner2.y); iy++) {
                            if (isBitOn(bm, box->corner0.x - 1, iy)) {
                                    turnSideNotFree(&(box->freeSides), LEFT);
                                break;
                            } /* if */
                        } /* for iy */

                        if ((boxLengthX(*box))*(boxLengthY(*box)+1) > maxSurf) {
                            /* Box may not exceed maximum surface. */
                            turnSideNotFree(&(box->freeSides), LEFT);
                            turnSideNotFree(&(box->freeSides), RIGHT);
                        } /* if */
                    } /* else */
                    break;

                case UP:
                    if (box->corner2.y >= mainBox.corner2.y) {
                        turnSideNotFree(&(box->freeSides), UP);
                    } /* if */
                    else {
                        for (ix=box->corner0.x; (ix <= box->corner2.x); ix++) {
                            if (isBitOn(bm, ix, box->corner2.y + 1)) {
                                    turnSideNotFree(&(box->freeSides), UP);
                                break;
                            } /* if */
                        } /* for ix */

                        if ((boxLengthX(*box)+1)*(boxLengthY(*box)) > maxSurf) {
                            /* Box may not exceed maximum surface. */
                            turnSideNotFree(&(box->freeSides), UP);
                            turnSideNotFree(&(box->freeSides), DOWN);
                        } /* if */
                    } /* else */
                    break;
            
                case RIGHT:
                    if (box->corner2.x >= mainBox.corner2.x) {
                        turnSideNotFree(&(box->freeSides), RIGHT);
                    } /* if */
                    else {
                        for (iy=box->corner0.y; (iy <= box->corner2.y); iy++) {
                            if (isBitOn(bm, box->corner2.x + 1, iy)) {
                                    turnSideNotFree(&(box->freeSides), RIGHT);
                                break;
                            } /* if */
                        } /* for iy */

                        if ((boxLengthX(*box))*(boxLengthY(*box)+1) > maxSurf) {
                            /* Box may not exceed maximum surface. */
                            turnSideNotFree(&(box->freeSides), RIGHT);
                            turnSideNotFree(&(box->freeSides), LEFT);
                        } /* if */
                    } /* else */
                    break;
            
                case DOWN:
                    if (box->corner0.y <= mainBox.corner0.y) {
                        turnSideNotFree(&(box->freeSides), DOWN);
                    } /* if */
                    else {
                        for (ix=box->corner0.x; (ix <= box->corner2.x); ix++) {
                            if (isBitOn(bm, ix, box->corner0.y - 1)) {
                                    turnSideNotFree(&(box->freeSides), DOWN);
                                break;
                            } /* if */
                        } /* for ix */

                        if ((boxLengthX(*box)+1)*(boxLengthY(*box)) > maxSurf) {
                            /* Box may not exceed maximum surface. */
                            turnSideNotFree(&(box->freeSides), DOWN);
                            turnSideNotFree(&(box->freeSides), UP);
                        } /* if */
                    } /* else */
                    break;
            } /* switch */

            if (isSideFree(box->freeSides, side)) {
                /* This side is really free. */
                return (side);
            } /* if */
        } /* if */
    } /* for i*/
} /* pickRandomSide */

/*----------------------------------------------------------------------------*/
/* expandBox()                                                                */
/*----------------------------------------------------------------------------*/

 void
expandBox(
  Box*      box,  /* The box to be expanded. */
  FreeSides side, /* The side in which direction it should expand. */
  Bitmap    bm    /* To scratch on what space the expanded box takes. */
) {
  int  i;  /* Loop variable. */

    switch (side) {
        case LEFT:
            (box->corner0.x)--;
            for (i=box->corner0.y; (i <= box->corner2.y); i++) {
                turnBitOn(bm, box->corner0.x, i);
            } /* for i */
            break;
        case UP:
            (box->corner2.y)++;
            for (i=box->corner0.x; (i <= box->corner2.x); i++) {
                turnBitOn(bm, i, (box->corner2.y));
            } /* for i */
            break;
        case RIGHT:
            (box->corner2.x)++;
            for (i=box->corner0.y; (i <= box->corner2.y); i++) {
                turnBitOn(bm, box->corner2.x, i);
            } /* for i */
            break;
        case DOWN:
            (box->corner0.y)--;
            for (i=box->corner0.x; (i <= box->corner2.x); i++) {
                turnBitOn(bm, i, box->corner0.y);
            } /* for i */
            break;
    } /* switch side */
} /* expandBox */

/*----------------------------------------------------------------------------*/
/* findHole()                                                                 */
/*----------------------------------------------------------------------------*/

 Boolean
findHole(
  Bitmap bm,    /* To search in for a hole. */
  Box    mainB, /* To know the bounds of the Bitmap bm */
  int*   holeX, /* If hole was found? the x-coordinate :. */
  int*   holeY  /* If hole was found? the y-coordinate :. */
) {
  static Boolean first = TRUE; /* TRUE if this is the first call to findHole.*/
  static int     x;            /* Optimalization. The last x-row checked. */

    if (first) {
        x = mainB.corner0.x;
        first = FALSE;
    } /* if */

    for (*holeX=x; (*holeX <= mainB.corner2.x); (*holeX)++) {
        for (*holeY=mainB.corner0.y; (*holeY <= mainB.corner2.y); (*holeY)++) {
            if (! isBitOn(bm, *holeX, *holeY)) {
		x = *holeX;
                return (TRUE);
            } /* if */
        } /* for holeY */
    } /* for holeX */

    return (FALSE);
} /* findHole */

/*----------------------------------------------------------------------------*/
/* writeBoxes()                                                               */
/*----------------------------------------------------------------------------*/

 void
writeBoxes(
  BoxArray boxArray,  /* The boxArray to be written. */
  int      nrOfBoxes, /* Number of boxes of the boxArray to be written. */
  int      scaleX,    /* The x-scale to convert the sizes to.  */
  int      scaleY     /* The y-scale to convert the sizes to. */
) {
  Box*  box;  /* Box to be written */
  int   i;    /* Loop variable */

    for (i=0; (i < nrOfBoxes); i++) {
	writeBox(*(getBox(boxArray, i)), scaleX, scaleY);
    } /* for i */
    
} /* writeBoxes */

/*----------------------------------------------------------------------------*/
/* writeBox()                                                                 */
/*----------------------------------------------------------------------------*/

 void
writeBox(
  Box box,    /* The boxList to be written. */
  int scaleX, /* The x-scale to convert the sizes to.  */
  int scaleY  /* The y-scale to convert the sizes to. */
) {
    printf("%d\t%d\t\t%d\t%d\n", box.corner0.x * scaleX,
	   box.corner0.y  * scaleY, (box.corner2.x + 1) * scaleX,
	   (box.corner2.y + 1) * scaleY); 
} /* writeBox */

/*----------------------------------------------------------------------------*/
/* error()                                                                    */
/*----------------------------------------------------------------------------*/

 void
error(
  char message[] /* Message to put on stderr. */
) {
    fprintf(stderr,"%s\n\n", message);
    exit(ERR);
} /* error */

/*##                                                                        ##*/
/*####   main.c :                                                         ####*/
/*############################################################################*/
