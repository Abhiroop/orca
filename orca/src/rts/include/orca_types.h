/*
 * (c) copyright 1995 by the Vrije Universiteit, Amsterdam, The Netherlands.
 * For full copyright and restrictions on use see the file COPYRIGHT in the
 * top level of the Orca distribution.
 */

/* $Id: orca_types.h,v 1.30 1998/06/11 12:00:50 ceriel Exp $ */

#ifndef __orca_types_h__
#define __orca_types_h__

typedef struct t_object t_object;
typedef struct type_descr tp_dscr;

#include <stddef.h>
#include "error.h"
#ifdef DATA_PARALLEL
#include <po.h>
#endif

#ifdef PANDA4
#include <pan_sys.h>
#endif

/* Silly macro to get a comma in a macro parameter.
   We sometimes need this in generic instantiations.
*/
#define COMMA	,
#define NOTHING	/* nothing */


/***************************************************************************
 *      P R O C E S S E S
 ***************************************************************************/

/* Process descriptors are used for marshalling parameters during a fork.
   They are generated by the compiler, one for each process type.
*/

typedef struct sharg {
	double	arg_score;	/* score */
	double	arg_naccess;	/* # of accesses by proc */
	double	arg_uncertainty;/* uncertainty about score */
} sh_args;

typedef struct proc_descr {
	void	(*prc_name)(void **);
	tp_dscr	*prc_func;	/* function descriptor of process */
	int	prc_registration; /* registration number of this descriptor */
	sh_args *prc_shargs;	/* one for each argument */
	char	*prc_trc_name;
	int	(*prc_size_args)(void **);
#ifndef PANDA4
	char	*(*prc_marshall_args)(char *, void **);
	char	*(*prc_unmarshall_args)(char *, void **);
#else
	pan_iovec_p
		(*prc_marshall_args)(pan_iovec_p, void **);
	void	(*prc_unmarshall_args)(void *, void **);
#endif
} prc_dscr;


/***************************************************************************
 *      O P E R A T I O N S
 ***************************************************************************/

/* Operation descriptors are used for marshalling parameters during a
   remotely executed operation. Unlike processes, operations can have
   OUT parameters and result values. The guards are divided by the compiler
   into two groups: those that only read the object and those that may read
   and modify the object's data. These groups are translated into separate
   procedures. The operation descriptor contains the addesses of these
   procedures. These procedures have two parameters: one indicating the
   object, and one indicating a list of addresses of parameters and result
   value.
*/

typedef struct op_descr {
	int	(*op_read_alts)(t_object *, void **);
	int	(*op_write_alts)(t_object *, void **);
	tp_dscr	*op_func;	/* a function descriptor for the operation */
	int	op_index;	/* all operations on an object are
				   numbered for identification purposes.
				   This is the number.
				   Numbers 0 and 1 are reserved for
				   reading and assigning the object.
				*/
	int	op_flags;
#define OP_BLOCKING	01
#define OP_PURE_WRITE	02
	char	*op_trc_name;	/* name of this operation. */
	int	(*op_size_op_call)(void **);
#ifndef PANDA4
	char	*(*op_marshall_op_call)(char *, void **);
	char	*(*op_unmarshall_op_call)(char *, void ***);
#else
	pan_iovec_p
		(*op_marshall_op_call)(pan_iovec_p, void **);
	void	(*op_unmarshall_op_call)(void *, void ***);
#endif
	int	(*op_size_op_return)(void **);
#ifndef PANDA4
	char	*(*op_marshall_op_return)(char *, void **);
	char	*(*op_unmarshall_op_return)(char *, void **);
#else
	pan_iovec_p
		(*op_marshall_op_return)(pan_iovec_p, void **);
	void	(*op_unmarshall_op_return)(void *, void **);
#endif
	void	(*op_free_op_return)(void **);
} op_dscr;

typedef struct obj_info {
	int	(*obj_size_obj)(t_object *);
#ifndef PANDA4
	char	*(*obj_marshall_obj)(char *, t_object *);
	char	*(*obj_unmarshall_obj)(char *, t_object *);
#else
	pan_iovec_p
		(*obj_marshall_obj)(pan_iovec_p, t_object *);
	void	(*obj_unmarshall_obj)(void *, t_object *);
#endif
	void	(*obj_rec_free)(void *);
	op_dscr	*obj_operations;
} obj_info;

/***************************************************************************
 *      G E N E R I C S
 ***************************************************************************/

/* Macros for name generation for generic instantiations. */
#define _concat_(a,b)	a ## b
#define _concat(a,b)	_concat_(a,b)
#define _str_(a)	# a
#define _str(a)		_str_(a)


/***************************************************************************
 *      T Y P E S
 ***************************************************************************/

/* For every type, either user-defined or built-in, such a descriptor
   exists at runtime. These descriptors are constant, and are created
   using the structure-initializing mechanism of C.
   The type descriptor structure would be best represented as a structure
   containing a common part for all descriptors, and a union for the
   part that differs, depending on the type.  Unfortunately, union
   initialization as is needed for this implementation does not exist in
   ANSI C, so instead there is one descriptor structure that is able to
   describe all data types, and we use macros to access some of the fields.
   The fields used for all type descriptors are:
   td_type	Indicates the basic type of the descriptor
		(and the data it describes).
   td_size	Indicates the size of objects of this type, as the compiler
		allocates them (notice that this does not always indicate the
		real size, because some parts may be allocated dynamically).
   td_flags	used for the following flags:
		DYNAMIC	indicates that the type has parts that must be
			allocated dynamically.
		NO_EQ	indicates that the type may not be compared for
			equality.
   The other fields depend on the value of the td_type field and are described
   below.
*/

/* Typedefs for the basic Orca types. */
typedef int		t_integer;
typedef long		t_longint;
typedef short		t_shortint;
typedef double		t_real;
typedef double		t_longreal;
typedef float		t_shortreal;
typedef unsigned char	t_char;
typedef unsigned char	t_enum;
typedef unsigned int	t_longenum;
typedef t_enum		t_boolean;

/* The type descriptor structure. */
struct type_descr {
	int	td_type;
/* The possible values for "td_type" are: */
#define	INTEGER		0x01
/* #define LONGINT		0x02 */
#define REAL		0x03
/* #define LONGREAL	0x04 */
#define ENUM		0x05
#define LONGENUM	0x06
#define CHAR		0x07
#define RECORD		0x08
#define OBJECT		0x09
#define UNION		0x0A
#define ARRAY		0x0B
#define SET		0x0C
#define BAG		0x0D
#define NODENAME	0x0E
#define GRAPH		0x0F
#define FUNCTION	0x10
#define POBJECT		0x11
#define FIXED_ARRAY	0x12
	size_t	td_size;
	int	td_flags;
/* Possible flags are: */
#define	DYNAMIC		0x01
#define	NO_EQ		0x02
#define INIT_CODE	0x04
#define HAS_OBJECTS	0x08
#define PARTITIONED	0x10
/* The next couple of fields are interpreted differently, depending on the
   value of td_type. See the description below for details. Macros are
   used to rename the fields.
*/
	tp_dscr *td_misc1;
	int	td_misc2;
	void	*td_misc3;
};

/* For ENUM: */
/* For enumerations, td_misc1 and td_misc3 are not used, td_misc2 indicates
   the number of enumeration literals in this type.
*/
#define td_nenums(tp)	((tp)->td_misc2)

/* For RECORD: */
typedef struct fld_descr {
	size_t	fld_offset;
	tp_dscr *fld_descr;
} fld_dscr;
/* For records, td_misc1 is not used. td_misc2 indicates the
   number of fields, and td_misc3 is a pointer to an array of
   "struct fld_descr", with one element for each field.
*/
#define td_nfields(tp)	((tp)->td_misc2)
#define td_fields(tp)	((fld_dscr *)((tp)->td_misc3))

/* For OBJECT: */
/* For objects, td_misc1 indicates the record type of the object variables,
   td_misc2 indicates the registration number of this object descriptor,
   and td_misc3 is a pointer to an array of operation descriptors, with one
   element for each operation defined for this object.
*/
#define td_objrec(tp)	((tp)->td_misc1)
#define td_registration(tp) \
			((tp)->td_misc2)
#define td_objinfo(tp)	((obj_info *)((tp)->td_misc3))
#define td_operations(tp) \
			(td_objinfo(tp)->obj_operations)

/* For UNION: */
typedef struct variant_descr {
	t_integer	var_tagval;
	size_t	var_offset;
	tp_dscr	*var_descr;
} var_dscr;
/* For unions, td_misc1 indicates the type descriptor of the union tag,
   td_misc2 indicates the number of union variants, and td_misc3 is a pointer
   to an array of "struct variant_descr", with one element for each variant.
*/
#define td_nvariants(tp)	((tp)->td_misc2)
#define td_variants(tp)	((var_dscr *)((tp)->td_misc3))
#define td_tagdscr(tp)	((tp)->td_misc1)

/* For ARRAY: */
/* For arrays, td_misc1 indicates the type descriptor of the elements,
   td_misc2 indicates the number of dimensions, and td_misc3 is a pointer
   to an array of "tp_dscr *", with one element for each dimension.
*/
#define td_elemdscr(tp)	((tp)->td_misc1)
#define td_ndim(tp)	((tp)->td_misc2)
#define td_indexdscr(tp)	((tp_dscr **) ((tp)->td_misc3))

/* For SET and BAG: use td_elemdscr as for ARRAY.
   td_misc3 indicates a pointer to a structure containing several function
   pointers.
*/

typedef struct set_descr {
   void (*set_free)(void *);
   void (*set_assign)(void *, void *);
   int (*set_elcompare)(void *, void *);
   void (*set_elfree)(void *);
   void (*set_elassign)(void *, void *);
} set_dscr;

#define td_setdscr(tp)	((set_dscr *)((tp)->td_misc3))
#define td_freefunc(tp)	(td_setdscr(tp)->set_free)
#define td_elfreefunc(tp) \
			(td_setdscr(tp)->set_elfree)
#define td_sassign(tp)	(td_setdscr(tp)->set_assign)
#define td_elcmp(tp)	(td_setdscr(tp)->set_elcompare)
#define td_elassign(tp) \
			(td_setdscr(tp)->set_elassign)


/* For NODENAME: */
/* For nodenames, td_misc1 indicates the type descriptor of the graph type
   of the nodename type.
*/
#define td_graphdscr(tp)	((tp)->td_misc1)

/* For GRAPH: */
/* For graphs, td_misc1 indicates the type descriptor of the root (as a record),
   td_misc2 indicates the offset of the root record within the graph struct,
   and td_misc3 indicates the type descriptor of the nodes (also as a record).
*/
#define td_rootdscr(tp)	((tp)->td_misc1)
#define td_nodedscr(tp)	((tp_dscr *) ((tp)->td_misc3))
#define td_rootoff(tp)	((tp)->td_misc2)

/* For FUNCTION: */
typedef struct param_descr {
	int	par_mode;	/* IN, OUT or SHARED */
#define IN	0
#define OUT	1
#define SHARED	2
#define GATHERED 3
#define REDUCED	4
	tp_dscr	*par_descr;	/* type descriptor of parameter */
	void	(*par_copy)(void *, void *);
	void	(*par_free)(void *);
} par_dscr;
/* For functions, td_misc1 indicates the type descriptor of the function result
   type, td_misc2 indicates the number of parameters, and td_misc3 is a
   pointer to an array of "struct param_descr", with one element for each
   parameter.
*/
#define td_resultdscr(tp) \
			((tp)->td_misc1)
#define td_nparams(tp)	((tp)->td_misc2)
#define td_params(tp)	((par_dscr *) ((tp)->td_misc3))

/* Descriptors for built-in types. */
extern tp_dscr
	td_integer,
	td_longint,
	td_shortint,
	td_real,
	td_longreal,
	td_shortreal,
	td_char,
	td_boolean,
	td_string,
	td_nodename;

#define ARRAY_TYPE(ndims) \
struct { \
	void	*a_data; \
	int	a_offset; \
	int	a_sz; \
	struct { \
		int	a_lwb; \
		int	a_nel; \
	} a_dims[ndims]; \
}

typedef ARRAY_TYPE(1) t_array;

typedef t_array	t_string;
#define batinit_string(s, nestinit, lb, ub, n) { \
		a_allocate(s, 1, 1, lb, ub); \
	}

#ifdef NO_AGE
typedef int	t_nodename;	/* index in master table */
#else
typedef struct {
	int	n_age;
	int	n_index;	/* index in master table */
} t_nodename;
#endif

/* A list of free nodes is maintained for each graph, through
   the g_freelist and g_nextfree fields. An odd g_age means the node is in use,
   an even g_age means that it is free.
*/

typedef struct t_mt {
	int	g_age;
	union {
	    int	g__nextfree;
	    void *g__node;
	} g_x;
#define g_nextfree	g_x.g__nextfree
#define g_node		g_x.g__node
} t_mt;

typedef struct	t_ndfree {
	struct t_ndfree
		*g_nxtblk;
	void	*g_blk;
} t_ndfree;

#define nodeisfree(nd)	(! ((nd)->g_age & 1))

typedef struct t_ghead {
	int	g__size;		/* size of master table */
	int	g__freelist;		/* g__size and g__freelist should be
					   the first two fields in this
					   struct for marshalling purposes.
					*/
	t_mt	*g__mt;			/* reference to master table */
	void	*g__freenodes;
	t_ndfree
		*g__ndlist;
} t_ghead;

typedef struct t_graph {
	t_ghead g_grph;
#define g_size		g_grph.g__size
#define g_shared	g_grph.g__shared
#define g_freelist	g_grph.g__freelist
#define g_mt		g_grph.g__mt
#define g_freenodes	g_grph.g__freenodes
#define g_ndlist	g_grph.g__ndlist
	int	g_dummy;
} t_graph;

#define INITSZ	64

/* For unions: */

typedef struct t_union {
	t_integer	u_tagval;
	t_boolean	u_init;
} t_union;

typedef struct t_elemhdr {
	struct t_elem	*ee_next;
	unsigned short	ee_mask;
	unsigned short	ee_count;
} t_elemhdr;

struct t_elem {
	t_elemhdr	e_hdr;
#define e_next	e_hdr.ee_next
#define e_mask	e_hdr.ee_mask
#define e_count	e_hdr.ee_count
	char		e_buf[1];
};

#define MAXELC	16

typedef struct t_elem t_elem;

typedef struct t_set t_set;

struct t_set {
	t_elem	*s_elem;
	int	s_nelem;
};

typedef t_set t_bag;

/* An object structure has two fields: a field "o_fields" which must
   be first, and which refers to a structure containing the object fields,
   and a field o_rtsdep, which is of a runtime-system dependent type
   "t_objrts". For objects, every process has a copy of this struct,
   so any shared parts must be allocated dynamically.
*/
struct t_object {
	void		*o_fields;
	struct t_objrts	*o_rtsdep;
};

/* NIL */
extern t_nodename nil;

#include <rtsdep.h>

#endif /* __orca_types_h__ */
